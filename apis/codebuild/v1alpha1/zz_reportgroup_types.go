/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ExportConfigObservation struct {
}

type ExportConfigParameters struct {

	// +kubebuilder:validation:Optional
	S3Destination []S3DestinationParameters `json:"s3Destination,omitempty" tf:"s3_destination,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type ReportGroupObservation struct {
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	Created *string `json:"created,omitempty" tf:"created,omitempty"`

	TagsAll map[string]*string `json:"tagsAll,omitempty" tf:"tags_all,omitempty"`
}

type ReportGroupParameters struct {

	// +kubebuilder:validation:Optional
	DeleteReports *bool `json:"deleteReports,omitempty" tf:"delete_reports,omitempty"`

	// +kubebuilder:validation:Required
	ExportConfig []ExportConfigParameters `json:"exportConfig" tf:"export_config,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"-"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type S3DestinationObservation struct {
}

type S3DestinationParameters struct {

	// +kubebuilder:validation:Required
	Bucket *string `json:"bucket" tf:"bucket,omitempty"`

	// +kubebuilder:validation:Optional
	EncryptionDisabled *bool `json:"encryptionDisabled,omitempty" tf:"encryption_disabled,omitempty"`

	// +kubebuilder:validation:Required
	EncryptionKey *string `json:"encryptionKey" tf:"encryption_key,omitempty"`

	// +kubebuilder:validation:Optional
	Packaging *string `json:"packaging,omitempty" tf:"packaging,omitempty"`

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`
}

// ReportGroupSpec defines the desired state of ReportGroup
type ReportGroupSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ReportGroupParameters `json:"forProvider"`
}

// ReportGroupStatus defines the observed state of ReportGroup.
type ReportGroupStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ReportGroupObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// ReportGroup is the Schema for the ReportGroups API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tfaws}
type ReportGroup struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ReportGroupSpec   `json:"spec"`
	Status            ReportGroupStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ReportGroupList contains a list of ReportGroups
type ReportGroupList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ReportGroup `json:"items"`
}

// Repository type metadata.
var (
	ReportGroupKind             = "ReportGroup"
	ReportGroupGroupKind        = schema.GroupKind{Group: Group, Kind: ReportGroupKind}.String()
	ReportGroupKindAPIVersion   = ReportGroupKind + "." + GroupVersion.String()
	ReportGroupGroupVersionKind = GroupVersion.WithKind(ReportGroupKind)
)

func init() {
	SchemeBuilder.Register(&ReportGroup{}, &ReportGroupList{})
}
