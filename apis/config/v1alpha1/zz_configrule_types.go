/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ConfigRuleObservation struct {
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	RuleID *string `json:"ruleId,omitempty" tf:"rule_id,omitempty"`

	TagsAll map[string]*string `json:"tagsAll,omitempty" tf:"tags_all,omitempty"`
}

type ConfigRuleParameters struct {

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	InputParameters *string `json:"inputParameters,omitempty" tf:"input_parameters,omitempty"`

	// +kubebuilder:validation:Optional
	MaximumExecutionFrequency *string `json:"maximumExecutionFrequency,omitempty" tf:"maximum_execution_frequency,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"-"`

	// +kubebuilder:validation:Optional
	Scope []ScopeParameters `json:"scope,omitempty" tf:"scope,omitempty"`

	// +kubebuilder:validation:Required
	Source []SourceParameters `json:"source" tf:"source,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`
}

type ScopeObservation struct {
}

type ScopeParameters struct {

	// +kubebuilder:validation:Optional
	ComplianceResourceID *string `json:"complianceResourceId,omitempty" tf:"compliance_resource_id,omitempty"`

	// +kubebuilder:validation:Optional
	ComplianceResourceTypes []*string `json:"complianceResourceTypes,omitempty" tf:"compliance_resource_types,omitempty"`

	// +kubebuilder:validation:Optional
	TagKey *string `json:"tagKey,omitempty" tf:"tag_key,omitempty"`

	// +kubebuilder:validation:Optional
	TagValue *string `json:"tagValue,omitempty" tf:"tag_value,omitempty"`
}

type SourceDetailObservation struct {
}

type SourceDetailParameters struct {

	// +kubebuilder:validation:Optional
	EventSource *string `json:"eventSource,omitempty" tf:"event_source,omitempty"`

	// +kubebuilder:validation:Optional
	MaximumExecutionFrequency *string `json:"maximumExecutionFrequency,omitempty" tf:"maximum_execution_frequency,omitempty"`

	// +kubebuilder:validation:Optional
	MessageType *string `json:"messageType,omitempty" tf:"message_type,omitempty"`
}

type SourceObservation struct {
}

type SourceParameters struct {

	// +kubebuilder:validation:Required
	Owner *string `json:"owner" tf:"owner,omitempty"`

	// +kubebuilder:validation:Optional
	SourceDetail []SourceDetailParameters `json:"sourceDetail,omitempty" tf:"source_detail,omitempty"`

	// +kubebuilder:validation:Required
	SourceIdentifier *string `json:"sourceIdentifier" tf:"source_identifier,omitempty"`
}

// ConfigRuleSpec defines the desired state of ConfigRule
type ConfigRuleSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ConfigRuleParameters `json:"forProvider"`
}

// ConfigRuleStatus defines the observed state of ConfigRule.
type ConfigRuleStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ConfigRuleObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// ConfigRule is the Schema for the ConfigRules API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tfaws}
type ConfigRule struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ConfigRuleSpec   `json:"spec"`
	Status            ConfigRuleStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ConfigRuleList contains a list of ConfigRules
type ConfigRuleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ConfigRule `json:"items"`
}

// Repository type metadata.
var (
	ConfigRuleKind             = "ConfigRule"
	ConfigRuleGroupKind        = schema.GroupKind{Group: Group, Kind: ConfigRuleKind}.String()
	ConfigRuleKindAPIVersion   = ConfigRuleKind + "." + GroupVersion.String()
	ConfigRuleGroupVersionKind = GroupVersion.WithKind(ConfigRuleKind)
)

func init() {
	SchemeBuilder.Register(&ConfigRule{}, &ConfigRuleList{})
}
