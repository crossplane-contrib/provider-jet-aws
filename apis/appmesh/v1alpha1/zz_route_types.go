/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ActionWeightedTargetObservation struct {
}

type ActionWeightedTargetParameters struct {

	// +kubebuilder:validation:Required
	VirtualNode *string `json:"virtualNode" tf:"virtual_node,omitempty"`

	// +kubebuilder:validation:Required
	Weight *int64 `json:"weight" tf:"weight,omitempty"`
}

type GrpcRouteActionObservation struct {
}

type GrpcRouteActionParameters struct {

	// +kubebuilder:validation:Required
	WeightedTarget []WeightedTargetParameters `json:"weightedTarget" tf:"weighted_target,omitempty"`
}

type GrpcRouteMatchObservation struct {
}

type GrpcRouteMatchParameters struct {

	// +kubebuilder:validation:Optional
	Metadata []MetadataParameters `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// +kubebuilder:validation:Optional
	MethodName *string `json:"methodName,omitempty" tf:"method_name,omitempty"`

	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceName *string `json:"serviceName,omitempty" tf:"service_name,omitempty"`
}

type HTTPRouteActionWeightedTargetObservation struct {
}

type HTTPRouteActionWeightedTargetParameters struct {

	// +kubebuilder:validation:Required
	VirtualNode *string `json:"virtualNode" tf:"virtual_node,omitempty"`

	// +kubebuilder:validation:Required
	Weight *int64 `json:"weight" tf:"weight,omitempty"`
}

type HTTPRouteRetryPolicyObservation struct {
}

type HTTPRouteRetryPolicyParameters struct {

	// +kubebuilder:validation:Optional
	HTTPRetryEvents []*string `json:"httpRetryEvents,omitempty" tf:"http_retry_events,omitempty"`

	// +kubebuilder:validation:Required
	MaxRetries *int64 `json:"maxRetries" tf:"max_retries,omitempty"`

	// +kubebuilder:validation:Required
	PerRetryTimeout []HTTPRouteRetryPolicyPerRetryTimeoutParameters `json:"perRetryTimeout" tf:"per_retry_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	TCPRetryEvents []*string `json:"tcpRetryEvents,omitempty" tf:"tcp_retry_events,omitempty"`
}

type HTTPRouteRetryPolicyPerRetryTimeoutObservation struct {
}

type HTTPRouteRetryPolicyPerRetryTimeoutParameters struct {

	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`

	// +kubebuilder:validation:Required
	Value *int64 `json:"value" tf:"value,omitempty"`
}

type HTTPRouteTimeoutIdleObservation struct {
}

type HTTPRouteTimeoutIdleParameters struct {

	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`

	// +kubebuilder:validation:Required
	Value *int64 `json:"value" tf:"value,omitempty"`
}

type HTTPRouteTimeoutObservation struct {
}

type HTTPRouteTimeoutParameters struct {

	// +kubebuilder:validation:Optional
	Idle []HTTPRouteTimeoutIdleParameters `json:"idle,omitempty" tf:"idle,omitempty"`

	// +kubebuilder:validation:Optional
	PerRequest []HTTPRouteTimeoutPerRequestParameters `json:"perRequest,omitempty" tf:"per_request,omitempty"`
}

type HTTPRouteTimeoutPerRequestObservation struct {
}

type HTTPRouteTimeoutPerRequestParameters struct {

	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`

	// +kubebuilder:validation:Required
	Value *int64 `json:"value" tf:"value,omitempty"`
}

type HeaderMatchObservation struct {
}

type HeaderMatchParameters struct {

	// +kubebuilder:validation:Optional
	Exact *string `json:"exact,omitempty" tf:"exact,omitempty"`

	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// +kubebuilder:validation:Optional
	Range []MatchRangeParameters `json:"range,omitempty" tf:"range,omitempty"`

	// +kubebuilder:validation:Optional
	Regex *string `json:"regex,omitempty" tf:"regex,omitempty"`

	// +kubebuilder:validation:Optional
	Suffix *string `json:"suffix,omitempty" tf:"suffix,omitempty"`
}

type HeaderMatchRangeObservation struct {
}

type HeaderMatchRangeParameters struct {

	// +kubebuilder:validation:Required
	End *int64 `json:"end" tf:"end,omitempty"`

	// +kubebuilder:validation:Required
	Start *int64 `json:"start" tf:"start,omitempty"`
}

type HeaderObservation struct {
}

type HeaderParameters struct {

	// +kubebuilder:validation:Optional
	Invert *bool `json:"invert,omitempty" tf:"invert,omitempty"`

	// +kubebuilder:validation:Optional
	Match []HeaderMatchParameters `json:"match,omitempty" tf:"match,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

type Http2RouteRetryPolicyObservation struct {
}

type Http2RouteRetryPolicyParameters struct {

	// +kubebuilder:validation:Optional
	HTTPRetryEvents []*string `json:"httpRetryEvents,omitempty" tf:"http_retry_events,omitempty"`

	// +kubebuilder:validation:Required
	MaxRetries *int64 `json:"maxRetries" tf:"max_retries,omitempty"`

	// +kubebuilder:validation:Required
	PerRetryTimeout []RetryPolicyPerRetryTimeoutParameters `json:"perRetryTimeout" tf:"per_retry_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	TCPRetryEvents []*string `json:"tcpRetryEvents,omitempty" tf:"tcp_retry_events,omitempty"`
}

type Http2RouteTimeoutObservation struct {
}

type Http2RouteTimeoutParameters struct {

	// +kubebuilder:validation:Optional
	Idle []TimeoutIdleParameters `json:"idle,omitempty" tf:"idle,omitempty"`

	// +kubebuilder:validation:Optional
	PerRequest []TimeoutPerRequestParameters `json:"perRequest,omitempty" tf:"per_request,omitempty"`
}

type IdleObservation struct {
}

type IdleParameters struct {

	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`

	// +kubebuilder:validation:Required
	Value *int64 `json:"value" tf:"value,omitempty"`
}

type MatchHeaderMatchObservation struct {
}

type MatchHeaderMatchParameters struct {

	// +kubebuilder:validation:Optional
	Exact *string `json:"exact,omitempty" tf:"exact,omitempty"`

	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// +kubebuilder:validation:Optional
	Range []HeaderMatchRangeParameters `json:"range,omitempty" tf:"range,omitempty"`

	// +kubebuilder:validation:Optional
	Regex *string `json:"regex,omitempty" tf:"regex,omitempty"`

	// +kubebuilder:validation:Optional
	Suffix *string `json:"suffix,omitempty" tf:"suffix,omitempty"`
}

type MatchHeaderObservation struct {
}

type MatchHeaderParameters struct {

	// +kubebuilder:validation:Optional
	Invert *bool `json:"invert,omitempty" tf:"invert,omitempty"`

	// +kubebuilder:validation:Optional
	Match []MatchHeaderMatchParameters `json:"match,omitempty" tf:"match,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

type MatchRangeObservation struct {
}

type MatchRangeParameters struct {

	// +kubebuilder:validation:Required
	End *int64 `json:"end" tf:"end,omitempty"`

	// +kubebuilder:validation:Required
	Start *int64 `json:"start" tf:"start,omitempty"`
}

type MetadataMatchObservation struct {
}

type MetadataMatchParameters struct {

	// +kubebuilder:validation:Optional
	Exact *string `json:"exact,omitempty" tf:"exact,omitempty"`

	// +kubebuilder:validation:Optional
	Prefix *string `json:"prefix,omitempty" tf:"prefix,omitempty"`

	// +kubebuilder:validation:Optional
	Range []RangeParameters `json:"range,omitempty" tf:"range,omitempty"`

	// +kubebuilder:validation:Optional
	Regex *string `json:"regex,omitempty" tf:"regex,omitempty"`

	// +kubebuilder:validation:Optional
	Suffix *string `json:"suffix,omitempty" tf:"suffix,omitempty"`
}

type MetadataObservation struct {
}

type MetadataParameters struct {

	// +kubebuilder:validation:Optional
	Invert *bool `json:"invert,omitempty" tf:"invert,omitempty"`

	// +kubebuilder:validation:Optional
	Match []MetadataMatchParameters `json:"match,omitempty" tf:"match,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

type PerRequestObservation struct {
}

type PerRequestParameters struct {

	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`

	// +kubebuilder:validation:Required
	Value *int64 `json:"value" tf:"value,omitempty"`
}

type PerRetryTimeoutObservation struct {
}

type PerRetryTimeoutParameters struct {

	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`

	// +kubebuilder:validation:Required
	Value *int64 `json:"value" tf:"value,omitempty"`
}

type RangeObservation struct {
}

type RangeParameters struct {

	// +kubebuilder:validation:Required
	End *int64 `json:"end" tf:"end,omitempty"`

	// +kubebuilder:validation:Required
	Start *int64 `json:"start" tf:"start,omitempty"`
}

type RetryPolicyObservation struct {
}

type RetryPolicyParameters struct {

	// +kubebuilder:validation:Optional
	GrpcRetryEvents []*string `json:"grpcRetryEvents,omitempty" tf:"grpc_retry_events,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPRetryEvents []*string `json:"httpRetryEvents,omitempty" tf:"http_retry_events,omitempty"`

	// +kubebuilder:validation:Required
	MaxRetries *int64 `json:"maxRetries" tf:"max_retries,omitempty"`

	// +kubebuilder:validation:Required
	PerRetryTimeout []PerRetryTimeoutParameters `json:"perRetryTimeout" tf:"per_retry_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	TCPRetryEvents []*string `json:"tcpRetryEvents,omitempty" tf:"tcp_retry_events,omitempty"`
}

type RetryPolicyPerRetryTimeoutObservation struct {
}

type RetryPolicyPerRetryTimeoutParameters struct {

	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`

	// +kubebuilder:validation:Required
	Value *int64 `json:"value" tf:"value,omitempty"`
}

type RouteObservation struct {
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	CreatedDate *string `json:"createdDate,omitempty" tf:"created_date,omitempty"`

	LastUpdatedDate *string `json:"lastUpdatedDate,omitempty" tf:"last_updated_date,omitempty"`

	ResourceOwner *string `json:"resourceOwner,omitempty" tf:"resource_owner,omitempty"`

	TagsAll map[string]*string `json:"tagsAll,omitempty" tf:"tags_all,omitempty"`
}

type RouteParameters struct {

	// +kubebuilder:validation:Required
	MeshName *string `json:"meshName" tf:"mesh_name,omitempty"`

	// +kubebuilder:validation:Optional
	MeshOwner *string `json:"meshOwner,omitempty" tf:"mesh_owner,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"-"`

	// +kubebuilder:validation:Required
	Spec []RouteSpecParameters `json:"spec" tf:"spec,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Required
	VirtualRouterName *string `json:"virtualRouterName" tf:"virtual_router_name,omitempty"`
}

type RouteSpecObservation struct {
}

type RouteSpecParameters struct {

	// +kubebuilder:validation:Optional
	GrpcRoute []SpecGrpcRouteParameters `json:"grpcRoute,omitempty" tf:"grpc_route,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPRoute []SpecHTTPRouteParameters `json:"httpRoute,omitempty" tf:"http_route,omitempty"`

	// +kubebuilder:validation:Optional
	Http2Route []SpecHttp2RouteParameters `json:"http2Route,omitempty" tf:"http2_route,omitempty"`

	// +kubebuilder:validation:Optional
	Priority *int64 `json:"priority,omitempty" tf:"priority,omitempty"`

	// +kubebuilder:validation:Optional
	TCPRoute []TCPRouteParameters `json:"tcpRoute,omitempty" tf:"tcp_route,omitempty"`
}

type SpecGrpcRouteObservation struct {
}

type SpecGrpcRouteParameters struct {

	// +kubebuilder:validation:Required
	Action []GrpcRouteActionParameters `json:"action" tf:"action,omitempty"`

	// +kubebuilder:validation:Optional
	Match []GrpcRouteMatchParameters `json:"match,omitempty" tf:"match,omitempty"`

	// +kubebuilder:validation:Optional
	RetryPolicy []RetryPolicyParameters `json:"retryPolicy,omitempty" tf:"retry_policy,omitempty"`

	// +kubebuilder:validation:Optional
	Timeout []TimeoutParameters `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type SpecHTTPRouteActionObservation struct {
}

type SpecHTTPRouteActionParameters struct {

	// +kubebuilder:validation:Required
	WeightedTarget []HTTPRouteActionWeightedTargetParameters `json:"weightedTarget" tf:"weighted_target,omitempty"`
}

type SpecHTTPRouteMatchObservation struct {
}

type SpecHTTPRouteMatchParameters struct {

	// +kubebuilder:validation:Optional
	Header []MatchHeaderParameters `json:"header,omitempty" tf:"header,omitempty"`

	// +kubebuilder:validation:Optional
	Method *string `json:"method,omitempty" tf:"method,omitempty"`

	// +kubebuilder:validation:Required
	Prefix *string `json:"prefix" tf:"prefix,omitempty"`

	// +kubebuilder:validation:Optional
	Scheme *string `json:"scheme,omitempty" tf:"scheme,omitempty"`
}

type SpecHTTPRouteObservation struct {
}

type SpecHTTPRouteParameters struct {

	// +kubebuilder:validation:Required
	Action []SpecHTTPRouteActionParameters `json:"action" tf:"action,omitempty"`

	// +kubebuilder:validation:Required
	Match []SpecHTTPRouteMatchParameters `json:"match" tf:"match,omitempty"`

	// +kubebuilder:validation:Optional
	RetryPolicy []HTTPRouteRetryPolicyParameters `json:"retryPolicy,omitempty" tf:"retry_policy,omitempty"`

	// +kubebuilder:validation:Optional
	Timeout []HTTPRouteTimeoutParameters `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type SpecHttp2RouteActionObservation struct {
}

type SpecHttp2RouteActionParameters struct {

	// +kubebuilder:validation:Required
	WeightedTarget []ActionWeightedTargetParameters `json:"weightedTarget" tf:"weighted_target,omitempty"`
}

type SpecHttp2RouteMatchObservation struct {
}

type SpecHttp2RouteMatchParameters struct {

	// +kubebuilder:validation:Optional
	Header []HeaderParameters `json:"header,omitempty" tf:"header,omitempty"`

	// +kubebuilder:validation:Optional
	Method *string `json:"method,omitempty" tf:"method,omitempty"`

	// +kubebuilder:validation:Required
	Prefix *string `json:"prefix" tf:"prefix,omitempty"`

	// +kubebuilder:validation:Optional
	Scheme *string `json:"scheme,omitempty" tf:"scheme,omitempty"`
}

type SpecHttp2RouteObservation struct {
}

type SpecHttp2RouteParameters struct {

	// +kubebuilder:validation:Required
	Action []SpecHttp2RouteActionParameters `json:"action" tf:"action,omitempty"`

	// +kubebuilder:validation:Required
	Match []SpecHttp2RouteMatchParameters `json:"match" tf:"match,omitempty"`

	// +kubebuilder:validation:Optional
	RetryPolicy []Http2RouteRetryPolicyParameters `json:"retryPolicy,omitempty" tf:"retry_policy,omitempty"`

	// +kubebuilder:validation:Optional
	Timeout []Http2RouteTimeoutParameters `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type TCPRouteActionObservation struct {
}

type TCPRouteActionParameters struct {

	// +kubebuilder:validation:Required
	WeightedTarget []TCPRouteActionWeightedTargetParameters `json:"weightedTarget" tf:"weighted_target,omitempty"`
}

type TCPRouteActionWeightedTargetObservation struct {
}

type TCPRouteActionWeightedTargetParameters struct {

	// +kubebuilder:validation:Required
	VirtualNode *string `json:"virtualNode" tf:"virtual_node,omitempty"`

	// +kubebuilder:validation:Required
	Weight *int64 `json:"weight" tf:"weight,omitempty"`
}

type TCPRouteObservation struct {
}

type TCPRouteParameters struct {

	// +kubebuilder:validation:Required
	Action []TCPRouteActionParameters `json:"action" tf:"action,omitempty"`

	// +kubebuilder:validation:Optional
	Timeout []TCPRouteTimeoutParameters `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type TCPRouteTimeoutIdleObservation struct {
}

type TCPRouteTimeoutIdleParameters struct {

	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`

	// +kubebuilder:validation:Required
	Value *int64 `json:"value" tf:"value,omitempty"`
}

type TCPRouteTimeoutObservation struct {
}

type TCPRouteTimeoutParameters struct {

	// +kubebuilder:validation:Optional
	Idle []TCPRouteTimeoutIdleParameters `json:"idle,omitempty" tf:"idle,omitempty"`
}

type TimeoutIdleObservation struct {
}

type TimeoutIdleParameters struct {

	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`

	// +kubebuilder:validation:Required
	Value *int64 `json:"value" tf:"value,omitempty"`
}

type TimeoutObservation struct {
}

type TimeoutParameters struct {

	// +kubebuilder:validation:Optional
	Idle []IdleParameters `json:"idle,omitempty" tf:"idle,omitempty"`

	// +kubebuilder:validation:Optional
	PerRequest []PerRequestParameters `json:"perRequest,omitempty" tf:"per_request,omitempty"`
}

type TimeoutPerRequestObservation struct {
}

type TimeoutPerRequestParameters struct {

	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`

	// +kubebuilder:validation:Required
	Value *int64 `json:"value" tf:"value,omitempty"`
}

type WeightedTargetObservation struct {
}

type WeightedTargetParameters struct {

	// +kubebuilder:validation:Required
	VirtualNode *string `json:"virtualNode" tf:"virtual_node,omitempty"`

	// +kubebuilder:validation:Required
	Weight *int64 `json:"weight" tf:"weight,omitempty"`
}

// RouteSpec defines the desired state of Route
type RouteSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     RouteParameters `json:"forProvider"`
}

// RouteStatus defines the observed state of Route.
type RouteStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        RouteObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Route is the Schema for the Routes API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tfaws}
type Route struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              RouteSpec   `json:"spec"`
	Status            RouteStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// RouteList contains a list of Routes
type RouteList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Route `json:"items"`
}

// Repository type metadata.
var (
	RouteKind             = "Route"
	RouteGroupKind        = schema.GroupKind{Group: Group, Kind: RouteKind}.String()
	RouteKindAPIVersion   = RouteKind + "." + GroupVersion.String()
	RouteGroupVersionKind = GroupVersion.WithKind(RouteKind)
)

func init() {
	SchemeBuilder.Register(&Route{}, &RouteList{})
}
