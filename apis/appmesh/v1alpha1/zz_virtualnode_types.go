/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AwsCloudMapObservation struct {
}

type AwsCloudMapParameters struct {

	// +kubebuilder:validation:Optional
	Attributes map[string]*string `json:"attributes,omitempty" tf:"attributes,omitempty"`

	// +kubebuilder:validation:Required
	NamespaceName *string `json:"namespaceName" tf:"namespace_name,omitempty"`

	// +kubebuilder:validation:Required
	ServiceName *string `json:"serviceName" tf:"service_name,omitempty"`
}

type BackendDefaultsClientPolicyObservation struct {
}

type BackendDefaultsClientPolicyParameters struct {

	// +kubebuilder:validation:Optional
	TLS []BackendDefaultsClientPolicyTLSParameters `json:"tls,omitempty" tf:"tls,omitempty"`
}

type BackendDefaultsClientPolicyTLSCertificateObservation struct {
}

type BackendDefaultsClientPolicyTLSCertificateParameters struct {

	// +kubebuilder:validation:Optional
	File []ClientPolicyTLSCertificateFileParameters `json:"file,omitempty" tf:"file,omitempty"`

	// +kubebuilder:validation:Optional
	Sds []ClientPolicyTLSCertificateSdsParameters `json:"sds,omitempty" tf:"sds,omitempty"`
}

type BackendDefaultsClientPolicyTLSObservation struct {
}

type BackendDefaultsClientPolicyTLSParameters struct {

	// +kubebuilder:validation:Optional
	Certificate []BackendDefaultsClientPolicyTLSCertificateParameters `json:"certificate,omitempty" tf:"certificate,omitempty"`

	// +kubebuilder:validation:Optional
	Enforce *bool `json:"enforce,omitempty" tf:"enforce,omitempty"`

	// +kubebuilder:validation:Optional
	Ports []*int64 `json:"ports,omitempty" tf:"ports,omitempty"`

	// +kubebuilder:validation:Required
	Validation []BackendDefaultsClientPolicyTLSValidationParameters `json:"validation" tf:"validation,omitempty"`
}

type BackendDefaultsClientPolicyTLSValidationObservation struct {
}

type BackendDefaultsClientPolicyTLSValidationParameters struct {

	// +kubebuilder:validation:Optional
	SubjectAlternativeNames []ClientPolicyTLSValidationSubjectAlternativeNamesParameters `json:"subjectAlternativeNames,omitempty" tf:"subject_alternative_names,omitempty"`

	// +kubebuilder:validation:Required
	Trust []ClientPolicyTLSValidationTrustParameters `json:"trust" tf:"trust,omitempty"`
}

type BackendObservation struct {
}

type BackendParameters struct {

	// +kubebuilder:validation:Required
	VirtualService []BackendVirtualServiceParameters `json:"virtualService" tf:"virtual_service,omitempty"`
}

type BackendVirtualServiceObservation struct {
}

type BackendVirtualServiceParameters struct {

	// +kubebuilder:validation:Optional
	ClientPolicy []VirtualServiceClientPolicyParameters `json:"clientPolicy,omitempty" tf:"client_policy,omitempty"`

	// +kubebuilder:validation:Required
	VirtualServiceName *string `json:"virtualServiceName" tf:"virtual_service_name,omitempty"`
}

type BaseEjectionDurationObservation struct {
}

type BaseEjectionDurationParameters struct {

	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`

	// +kubebuilder:validation:Required
	Value *int64 `json:"value" tf:"value,omitempty"`
}

type ClientPolicyTLSCertificateFileObservation struct {
}

type ClientPolicyTLSCertificateFileParameters struct {

	// +kubebuilder:validation:Required
	CertificateChain *string `json:"certificateChain" tf:"certificate_chain,omitempty"`

	// +kubebuilder:validation:Required
	PrivateKey *string `json:"privateKey" tf:"private_key,omitempty"`
}

type ClientPolicyTLSCertificateObservation struct {
}

type ClientPolicyTLSCertificateParameters struct {

	// +kubebuilder:validation:Optional
	File []TLSCertificateFileParameters `json:"file,omitempty" tf:"file,omitempty"`

	// +kubebuilder:validation:Optional
	Sds []TLSCertificateSdsParameters `json:"sds,omitempty" tf:"sds,omitempty"`
}

type ClientPolicyTLSCertificateSdsObservation struct {
}

type ClientPolicyTLSCertificateSdsParameters struct {

	// +kubebuilder:validation:Required
	SecretName *string `json:"secretName" tf:"secret_name,omitempty"`
}

type ClientPolicyTLSObservation struct {
}

type ClientPolicyTLSParameters struct {

	// +kubebuilder:validation:Optional
	Certificate []ClientPolicyTLSCertificateParameters `json:"certificate,omitempty" tf:"certificate,omitempty"`

	// +kubebuilder:validation:Optional
	Enforce *bool `json:"enforce,omitempty" tf:"enforce,omitempty"`

	// +kubebuilder:validation:Optional
	Ports []*int64 `json:"ports,omitempty" tf:"ports,omitempty"`

	// +kubebuilder:validation:Required
	Validation []ClientPolicyTLSValidationParameters `json:"validation" tf:"validation,omitempty"`
}

type ClientPolicyTLSValidationObservation struct {
}

type ClientPolicyTLSValidationParameters struct {

	// +kubebuilder:validation:Optional
	SubjectAlternativeNames []TLSValidationSubjectAlternativeNamesParameters `json:"subjectAlternativeNames,omitempty" tf:"subject_alternative_names,omitempty"`

	// +kubebuilder:validation:Required
	Trust []TLSValidationTrustParameters `json:"trust" tf:"trust,omitempty"`
}

type ClientPolicyTLSValidationSubjectAlternativeNamesMatchObservation struct {
}

type ClientPolicyTLSValidationSubjectAlternativeNamesMatchParameters struct {

	// +kubebuilder:validation:Required
	Exact []*string `json:"exact" tf:"exact,omitempty"`
}

type ClientPolicyTLSValidationSubjectAlternativeNamesObservation struct {
}

type ClientPolicyTLSValidationSubjectAlternativeNamesParameters struct {

	// +kubebuilder:validation:Required
	Match []ClientPolicyTLSValidationSubjectAlternativeNamesMatchParameters `json:"match" tf:"match,omitempty"`
}

type ClientPolicyTLSValidationTrustFileObservation struct {
}

type ClientPolicyTLSValidationTrustFileParameters struct {

	// +kubebuilder:validation:Required
	CertificateChain *string `json:"certificateChain" tf:"certificate_chain,omitempty"`
}

type ClientPolicyTLSValidationTrustObservation struct {
}

type ClientPolicyTLSValidationTrustParameters struct {

	// +kubebuilder:validation:Optional
	Acm []ValidationTrustAcmParameters `json:"acm,omitempty" tf:"acm,omitempty"`

	// +kubebuilder:validation:Optional
	File []ClientPolicyTLSValidationTrustFileParameters `json:"file,omitempty" tf:"file,omitempty"`

	// +kubebuilder:validation:Optional
	Sds []ClientPolicyTLSValidationTrustSdsParameters `json:"sds,omitempty" tf:"sds,omitempty"`
}

type ClientPolicyTLSValidationTrustSdsObservation struct {
}

type ClientPolicyTLSValidationTrustSdsParameters struct {

	// +kubebuilder:validation:Required
	SecretName *string `json:"secretName" tf:"secret_name,omitempty"`
}

type ConnectionPoolGrpcObservation struct {
}

type ConnectionPoolGrpcParameters struct {

	// +kubebuilder:validation:Required
	MaxRequests *int64 `json:"maxRequests" tf:"max_requests,omitempty"`
}

type ConnectionPoolHTTPObservation struct {
}

type ConnectionPoolHTTPParameters struct {

	// +kubebuilder:validation:Required
	MaxConnections *int64 `json:"maxConnections" tf:"max_connections,omitempty"`

	// +kubebuilder:validation:Optional
	MaxPendingRequests *int64 `json:"maxPendingRequests,omitempty" tf:"max_pending_requests,omitempty"`
}

type ConnectionPoolHttp2Observation struct {
}

type ConnectionPoolHttp2Parameters struct {

	// +kubebuilder:validation:Required
	MaxRequests *int64 `json:"maxRequests" tf:"max_requests,omitempty"`
}

type DNSObservation struct {
}

type DNSParameters struct {

	// +kubebuilder:validation:Required
	Hostname *string `json:"hostname" tf:"hostname,omitempty"`
}

type GrpcIdleObservation struct {
}

type GrpcIdleParameters struct {

	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`

	// +kubebuilder:validation:Required
	Value *int64 `json:"value" tf:"value,omitempty"`
}

type GrpcPerRequestObservation struct {
}

type GrpcPerRequestParameters struct {

	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`

	// +kubebuilder:validation:Required
	Value *int64 `json:"value" tf:"value,omitempty"`
}

type HTTPIdleObservation struct {
}

type HTTPIdleParameters struct {

	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`

	// +kubebuilder:validation:Required
	Value *int64 `json:"value" tf:"value,omitempty"`
}

type HTTPPerRequestObservation struct {
}

type HTTPPerRequestParameters struct {

	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`

	// +kubebuilder:validation:Required
	Value *int64 `json:"value" tf:"value,omitempty"`
}

type Http2IdleObservation struct {
}

type Http2IdleParameters struct {

	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`

	// +kubebuilder:validation:Required
	Value *int64 `json:"value" tf:"value,omitempty"`
}

type Http2PerRequestObservation struct {
}

type Http2PerRequestParameters struct {

	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`

	// +kubebuilder:validation:Required
	Value *int64 `json:"value" tf:"value,omitempty"`
}

type IntervalObservation struct {
}

type IntervalParameters struct {

	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`

	// +kubebuilder:validation:Required
	Value *int64 `json:"value" tf:"value,omitempty"`
}

type ListenerConnectionPoolObservation struct {
}

type ListenerConnectionPoolParameters struct {

	// +kubebuilder:validation:Optional
	Grpc []ConnectionPoolGrpcParameters `json:"grpc,omitempty" tf:"grpc,omitempty"`

	// +kubebuilder:validation:Optional
	HTTP []ConnectionPoolHTTPParameters `json:"http,omitempty" tf:"http,omitempty"`

	// +kubebuilder:validation:Optional
	Http2 []ConnectionPoolHttp2Parameters `json:"http2,omitempty" tf:"http2,omitempty"`

	// +kubebuilder:validation:Optional
	TCP []TCPParameters `json:"tcp,omitempty" tf:"tcp,omitempty"`
}

type ListenerHealthCheckObservation struct {
}

type ListenerHealthCheckParameters struct {

	// +kubebuilder:validation:Required
	HealthyThreshold *int64 `json:"healthyThreshold" tf:"healthy_threshold,omitempty"`

	// +kubebuilder:validation:Required
	IntervalMillis *int64 `json:"intervalMillis" tf:"interval_millis,omitempty"`

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	Port *int64 `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Required
	Protocol *string `json:"protocol" tf:"protocol,omitempty"`

	// +kubebuilder:validation:Required
	TimeoutMillis *int64 `json:"timeoutMillis" tf:"timeout_millis,omitempty"`

	// +kubebuilder:validation:Required
	UnhealthyThreshold *int64 `json:"unhealthyThreshold" tf:"unhealthy_threshold,omitempty"`
}

type ListenerPortMappingObservation struct {
}

type ListenerPortMappingParameters struct {

	// +kubebuilder:validation:Required
	Port *int64 `json:"port" tf:"port,omitempty"`

	// +kubebuilder:validation:Required
	Protocol *string `json:"protocol" tf:"protocol,omitempty"`
}

type ListenerTLSCertificateFileObservation struct {
}

type ListenerTLSCertificateFileParameters struct {

	// +kubebuilder:validation:Required
	CertificateChain *string `json:"certificateChain" tf:"certificate_chain,omitempty"`

	// +kubebuilder:validation:Required
	PrivateKey *string `json:"privateKey" tf:"private_key,omitempty"`
}

type ListenerTLSCertificateObservation struct {
}

type ListenerTLSCertificateParameters struct {

	// +kubebuilder:validation:Optional
	Acm []TLSCertificateAcmParameters `json:"acm,omitempty" tf:"acm,omitempty"`

	// +kubebuilder:validation:Optional
	File []ListenerTLSCertificateFileParameters `json:"file,omitempty" tf:"file,omitempty"`

	// +kubebuilder:validation:Optional
	Sds []ListenerTLSCertificateSdsParameters `json:"sds,omitempty" tf:"sds,omitempty"`
}

type ListenerTLSCertificateSdsObservation struct {
}

type ListenerTLSCertificateSdsParameters struct {

	// +kubebuilder:validation:Required
	SecretName *string `json:"secretName" tf:"secret_name,omitempty"`
}

type ListenerTLSValidationObservation struct {
}

type ListenerTLSValidationParameters struct {

	// +kubebuilder:validation:Optional
	SubjectAlternativeNames []ListenerTLSValidationSubjectAlternativeNamesParameters `json:"subjectAlternativeNames,omitempty" tf:"subject_alternative_names,omitempty"`

	// +kubebuilder:validation:Required
	Trust []ListenerTLSValidationTrustParameters `json:"trust" tf:"trust,omitempty"`
}

type ListenerTLSValidationSubjectAlternativeNamesMatchObservation struct {
}

type ListenerTLSValidationSubjectAlternativeNamesMatchParameters struct {

	// +kubebuilder:validation:Required
	Exact []*string `json:"exact" tf:"exact,omitempty"`
}

type ListenerTLSValidationSubjectAlternativeNamesObservation struct {
}

type ListenerTLSValidationSubjectAlternativeNamesParameters struct {

	// +kubebuilder:validation:Required
	Match []ListenerTLSValidationSubjectAlternativeNamesMatchParameters `json:"match" tf:"match,omitempty"`
}

type ListenerTLSValidationTrustFileObservation struct {
}

type ListenerTLSValidationTrustFileParameters struct {

	// +kubebuilder:validation:Required
	CertificateChain *string `json:"certificateChain" tf:"certificate_chain,omitempty"`
}

type ListenerTLSValidationTrustObservation struct {
}

type ListenerTLSValidationTrustParameters struct {

	// +kubebuilder:validation:Optional
	File []ListenerTLSValidationTrustFileParameters `json:"file,omitempty" tf:"file,omitempty"`

	// +kubebuilder:validation:Optional
	Sds []ListenerTLSValidationTrustSdsParameters `json:"sds,omitempty" tf:"sds,omitempty"`
}

type ListenerTLSValidationTrustSdsObservation struct {
}

type ListenerTLSValidationTrustSdsParameters struct {

	// +kubebuilder:validation:Required
	SecretName *string `json:"secretName" tf:"secret_name,omitempty"`
}

type ListenerTimeoutObservation struct {
}

type ListenerTimeoutParameters struct {

	// +kubebuilder:validation:Optional
	Grpc []TimeoutGrpcParameters `json:"grpc,omitempty" tf:"grpc,omitempty"`

	// +kubebuilder:validation:Optional
	HTTP []TimeoutHTTPParameters `json:"http,omitempty" tf:"http,omitempty"`

	// +kubebuilder:validation:Optional
	Http2 []TimeoutHttp2Parameters `json:"http2,omitempty" tf:"http2,omitempty"`

	// +kubebuilder:validation:Optional
	TCP []TimeoutTCPParameters `json:"tcp,omitempty" tf:"tcp,omitempty"`
}

type LoggingAccessLogFileObservation struct {
}

type LoggingAccessLogFileParameters struct {

	// +kubebuilder:validation:Required
	Path *string `json:"path" tf:"path,omitempty"`
}

type LoggingAccessLogObservation struct {
}

type LoggingAccessLogParameters struct {

	// +kubebuilder:validation:Optional
	File []LoggingAccessLogFileParameters `json:"file,omitempty" tf:"file,omitempty"`
}

type OutlierDetectionObservation struct {
}

type OutlierDetectionParameters struct {

	// +kubebuilder:validation:Required
	BaseEjectionDuration []BaseEjectionDurationParameters `json:"baseEjectionDuration" tf:"base_ejection_duration,omitempty"`

	// +kubebuilder:validation:Required
	Interval []IntervalParameters `json:"interval" tf:"interval,omitempty"`

	// +kubebuilder:validation:Required
	MaxEjectionPercent *int64 `json:"maxEjectionPercent" tf:"max_ejection_percent,omitempty"`

	// +kubebuilder:validation:Required
	MaxServerErrors *int64 `json:"maxServerErrors" tf:"max_server_errors,omitempty"`
}

type ServiceDiscoveryObservation struct {
}

type ServiceDiscoveryParameters struct {

	// +kubebuilder:validation:Optional
	AwsCloudMap []AwsCloudMapParameters `json:"awsCloudMap,omitempty" tf:"aws_cloud_map,omitempty"`

	// +kubebuilder:validation:Optional
	DNS []DNSParameters `json:"dns,omitempty" tf:"dns,omitempty"`
}

type SpecBackendDefaultsObservation struct {
}

type SpecBackendDefaultsParameters struct {

	// +kubebuilder:validation:Optional
	ClientPolicy []BackendDefaultsClientPolicyParameters `json:"clientPolicy,omitempty" tf:"client_policy,omitempty"`
}

type SpecListenerObservation struct {
}

type SpecListenerParameters struct {

	// +kubebuilder:validation:Optional
	ConnectionPool []ListenerConnectionPoolParameters `json:"connectionPool,omitempty" tf:"connection_pool,omitempty"`

	// +kubebuilder:validation:Optional
	HealthCheck []ListenerHealthCheckParameters `json:"healthCheck,omitempty" tf:"health_check,omitempty"`

	// +kubebuilder:validation:Optional
	OutlierDetection []OutlierDetectionParameters `json:"outlierDetection,omitempty" tf:"outlier_detection,omitempty"`

	// +kubebuilder:validation:Required
	PortMapping []ListenerPortMappingParameters `json:"portMapping" tf:"port_mapping,omitempty"`

	// +kubebuilder:validation:Optional
	TLS []SpecListenerTLSParameters `json:"tls,omitempty" tf:"tls,omitempty"`

	// +kubebuilder:validation:Optional
	Timeout []ListenerTimeoutParameters `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type SpecListenerTLSObservation struct {
}

type SpecListenerTLSParameters struct {

	// +kubebuilder:validation:Required
	Certificate []ListenerTLSCertificateParameters `json:"certificate" tf:"certificate,omitempty"`

	// +kubebuilder:validation:Required
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// +kubebuilder:validation:Optional
	Validation []ListenerTLSValidationParameters `json:"validation,omitempty" tf:"validation,omitempty"`
}

type SpecLoggingObservation struct {
}

type SpecLoggingParameters struct {

	// +kubebuilder:validation:Optional
	AccessLog []LoggingAccessLogParameters `json:"accessLog,omitempty" tf:"access_log,omitempty"`
}

type TCPIdleObservation struct {
}

type TCPIdleParameters struct {

	// +kubebuilder:validation:Required
	Unit *string `json:"unit" tf:"unit,omitempty"`

	// +kubebuilder:validation:Required
	Value *int64 `json:"value" tf:"value,omitempty"`
}

type TCPObservation struct {
}

type TCPParameters struct {

	// +kubebuilder:validation:Required
	MaxConnections *int64 `json:"maxConnections" tf:"max_connections,omitempty"`
}

type TLSCertificateAcmObservation struct {
}

type TLSCertificateAcmParameters struct {

	// +kubebuilder:validation:Required
	CertificateArn *string `json:"certificateArn" tf:"certificate_arn,omitempty"`
}

type TLSCertificateFileObservation struct {
}

type TLSCertificateFileParameters struct {

	// +kubebuilder:validation:Required
	CertificateChain *string `json:"certificateChain" tf:"certificate_chain,omitempty"`

	// +kubebuilder:validation:Required
	PrivateKey *string `json:"privateKey" tf:"private_key,omitempty"`
}

type TLSCertificateSdsObservation struct {
}

type TLSCertificateSdsParameters struct {

	// +kubebuilder:validation:Required
	SecretName *string `json:"secretName" tf:"secret_name,omitempty"`
}

type TLSValidationSubjectAlternativeNamesMatchObservation struct {
}

type TLSValidationSubjectAlternativeNamesMatchParameters struct {

	// +kubebuilder:validation:Required
	Exact []*string `json:"exact" tf:"exact,omitempty"`
}

type TLSValidationSubjectAlternativeNamesObservation struct {
}

type TLSValidationSubjectAlternativeNamesParameters struct {

	// +kubebuilder:validation:Required
	Match []TLSValidationSubjectAlternativeNamesMatchParameters `json:"match" tf:"match,omitempty"`
}

type TLSValidationTrustFileObservation struct {
}

type TLSValidationTrustFileParameters struct {

	// +kubebuilder:validation:Required
	CertificateChain *string `json:"certificateChain" tf:"certificate_chain,omitempty"`
}

type TLSValidationTrustObservation struct {
}

type TLSValidationTrustParameters struct {

	// +kubebuilder:validation:Optional
	Acm []TrustAcmParameters `json:"acm,omitempty" tf:"acm,omitempty"`

	// +kubebuilder:validation:Optional
	File []TLSValidationTrustFileParameters `json:"file,omitempty" tf:"file,omitempty"`

	// +kubebuilder:validation:Optional
	Sds []TLSValidationTrustSdsParameters `json:"sds,omitempty" tf:"sds,omitempty"`
}

type TLSValidationTrustSdsObservation struct {
}

type TLSValidationTrustSdsParameters struct {

	// +kubebuilder:validation:Required
	SecretName *string `json:"secretName" tf:"secret_name,omitempty"`
}

type TimeoutGrpcObservation struct {
}

type TimeoutGrpcParameters struct {

	// +kubebuilder:validation:Optional
	Idle []GrpcIdleParameters `json:"idle,omitempty" tf:"idle,omitempty"`

	// +kubebuilder:validation:Optional
	PerRequest []GrpcPerRequestParameters `json:"perRequest,omitempty" tf:"per_request,omitempty"`
}

type TimeoutHTTPObservation struct {
}

type TimeoutHTTPParameters struct {

	// +kubebuilder:validation:Optional
	Idle []HTTPIdleParameters `json:"idle,omitempty" tf:"idle,omitempty"`

	// +kubebuilder:validation:Optional
	PerRequest []HTTPPerRequestParameters `json:"perRequest,omitempty" tf:"per_request,omitempty"`
}

type TimeoutHttp2Observation struct {
}

type TimeoutHttp2Parameters struct {

	// +kubebuilder:validation:Optional
	Idle []Http2IdleParameters `json:"idle,omitempty" tf:"idle,omitempty"`

	// +kubebuilder:validation:Optional
	PerRequest []Http2PerRequestParameters `json:"perRequest,omitempty" tf:"per_request,omitempty"`
}

type TimeoutTCPObservation struct {
}

type TimeoutTCPParameters struct {

	// +kubebuilder:validation:Optional
	Idle []TCPIdleParameters `json:"idle,omitempty" tf:"idle,omitempty"`
}

type TrustAcmObservation struct {
}

type TrustAcmParameters struct {

	// +kubebuilder:validation:Required
	CertificateAuthorityArns []*string `json:"certificateAuthorityArns" tf:"certificate_authority_arns,omitempty"`
}

type ValidationTrustAcmObservation struct {
}

type ValidationTrustAcmParameters struct {

	// +kubebuilder:validation:Required
	CertificateAuthorityArns []*string `json:"certificateAuthorityArns" tf:"certificate_authority_arns,omitempty"`
}

type VirtualNodeObservation struct {
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	CreatedDate *string `json:"createdDate,omitempty" tf:"created_date,omitempty"`

	LastUpdatedDate *string `json:"lastUpdatedDate,omitempty" tf:"last_updated_date,omitempty"`

	ResourceOwner *string `json:"resourceOwner,omitempty" tf:"resource_owner,omitempty"`

	TagsAll map[string]*string `json:"tagsAll,omitempty" tf:"tags_all,omitempty"`
}

type VirtualNodeParameters struct {

	// +kubebuilder:validation:Required
	MeshName *string `json:"meshName" tf:"mesh_name,omitempty"`

	// +kubebuilder:validation:Optional
	MeshOwner *string `json:"meshOwner,omitempty" tf:"mesh_owner,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"-"`

	// +kubebuilder:validation:Required
	Spec []VirtualNodeSpecParameters `json:"spec" tf:"spec,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`
}

type VirtualNodeSpecObservation struct {
}

type VirtualNodeSpecParameters struct {

	// +kubebuilder:validation:Optional
	Backend []BackendParameters `json:"backend,omitempty" tf:"backend,omitempty"`

	// +kubebuilder:validation:Optional
	BackendDefaults []SpecBackendDefaultsParameters `json:"backendDefaults,omitempty" tf:"backend_defaults,omitempty"`

	// +kubebuilder:validation:Optional
	Listener []SpecListenerParameters `json:"listener,omitempty" tf:"listener,omitempty"`

	// +kubebuilder:validation:Optional
	Logging []SpecLoggingParameters `json:"logging,omitempty" tf:"logging,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceDiscovery []ServiceDiscoveryParameters `json:"serviceDiscovery,omitempty" tf:"service_discovery,omitempty"`
}

type VirtualServiceClientPolicyObservation struct {
}

type VirtualServiceClientPolicyParameters struct {

	// +kubebuilder:validation:Optional
	TLS []ClientPolicyTLSParameters `json:"tls,omitempty" tf:"tls,omitempty"`
}

// VirtualNodeSpec defines the desired state of VirtualNode
type VirtualNodeSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     VirtualNodeParameters `json:"forProvider"`
}

// VirtualNodeStatus defines the observed state of VirtualNode.
type VirtualNodeStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        VirtualNodeObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// VirtualNode is the Schema for the VirtualNodes API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tfaws}
type VirtualNode struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              VirtualNodeSpec   `json:"spec"`
	Status            VirtualNodeStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// VirtualNodeList contains a list of VirtualNodes
type VirtualNodeList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VirtualNode `json:"items"`
}

// Repository type metadata.
var (
	VirtualNodeKind             = "VirtualNode"
	VirtualNodeGroupKind        = schema.GroupKind{Group: Group, Kind: VirtualNodeKind}.String()
	VirtualNodeKindAPIVersion   = VirtualNodeKind + "." + GroupVersion.String()
	VirtualNodeGroupVersionKind = GroupVersion.WithKind(VirtualNodeKind)
)

func init() {
	SchemeBuilder.Register(&VirtualNode{}, &VirtualNodeList{})
}
