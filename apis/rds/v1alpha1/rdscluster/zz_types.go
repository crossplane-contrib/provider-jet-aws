/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

// +kubebuilder:object:generate=true
// +groupName=rds.aws.tf.crossplane.io
// +versionName=v1alpha1

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	apis "github.com/crossplane-contrib/provider-tf-aws/apis"
	v1alpha1 "github.com/crossplane-contrib/provider-tf-aws/apis/rds/v1alpha1"
)

type RdsClusterObservation struct {
	Arn string `json:"arn" tf:"arn"`

	ClusterResourceId string `json:"clusterResourceId" tf:"cluster_resource_id"`

	Endpoint string `json:"endpoint" tf:"endpoint"`

	EngineVersionActual string `json:"engineVersionActual" tf:"engine_version_actual"`

	HostedZoneId string `json:"hostedZoneId" tf:"hosted_zone_id"`

	ReaderEndpoint string `json:"readerEndpoint" tf:"reader_endpoint"`
}

type RdsClusterParameters struct {
	AllowMajorVersionUpgrade *bool `json:"allowMajorVersionUpgrade,omitempty" tf:"allow_major_version_upgrade"`

	ApplyImmediately *bool `json:"applyImmediately,omitempty" tf:"apply_immediately"`

	AvailabilityZones []string `json:"availabilityZones,omitempty" tf:"availability_zones"`

	BacktrackWindow *int64 `json:"backtrackWindow,omitempty" tf:"backtrack_window"`

	BackupRetentionPeriod *int64 `json:"backupRetentionPeriod,omitempty" tf:"backup_retention_period"`

	ClusterIdentifier *string `json:"clusterIdentifier,omitempty" tf:"cluster_identifier"`

	ClusterIdentifierPrefix *string `json:"clusterIdentifierPrefix,omitempty" tf:"cluster_identifier_prefix"`

	ClusterMembers []string `json:"clusterMembers,omitempty" tf:"cluster_members"`

	CopyTagsToSnapshot *bool `json:"copyTagsToSnapshot,omitempty" tf:"copy_tags_to_snapshot"`

	DatabaseName *string `json:"databaseName,omitempty" tf:"database_name"`

	DbClusterParameterGroupName *string `json:"dbClusterParameterGroupName,omitempty" tf:"db_cluster_parameter_group_name"`

	DbSubnetGroupName *string `json:"dbSubnetGroupName,omitempty" tf:"db_subnet_group_name"`

	DeletionProtection *bool `json:"deletionProtection,omitempty" tf:"deletion_protection"`

	EnableHttpEndpoint *bool `json:"enableHttpEndpoint,omitempty" tf:"enable_http_endpoint"`

	EnabledCloudwatchLogsExports []string `json:"enabledCloudwatchLogsExports,omitempty" tf:"enabled_cloudwatch_logs_exports"`

	Engine *string `json:"engine,omitempty" tf:"engine"`

	EngineMode *string `json:"engineMode,omitempty" tf:"engine_mode"`

	EngineVersion *string `json:"engineVersion,omitempty" tf:"engine_version"`

	FinalSnapshotIdentifier *string `json:"finalSnapshotIdentifier,omitempty" tf:"final_snapshot_identifier"`

	GlobalClusterIdentifier *string `json:"globalClusterIdentifier,omitempty" tf:"global_cluster_identifier"`

	IamDatabaseAuthenticationEnabled *bool `json:"iamDatabaseAuthenticationEnabled,omitempty" tf:"iam_database_authentication_enabled"`

	IamRoles []string `json:"iamRoles,omitempty" tf:"iam_roles"`

	KmsKeyId *string `json:"kmsKeyId,omitempty" tf:"kms_key_id"`

	MasterPassword *string `json:"masterPassword,omitempty" tf:"master_password"`

	MasterUsername *string `json:"masterUsername,omitempty" tf:"master_username"`

	Port *int64 `json:"port,omitempty" tf:"port"`

	PreferredBackupWindow *string `json:"preferredBackupWindow,omitempty" tf:"preferred_backup_window"`

	PreferredMaintenanceWindow *string `json:"preferredMaintenanceWindow,omitempty" tf:"preferred_maintenance_window"`

	ReplicationSourceIdentifier *string `json:"replicationSourceIdentifier,omitempty" tf:"replication_source_identifier"`

	RestoreToPointInTime []RestoreToPointInTimeParameters `json:"restoreToPointInTime,omitempty" tf:"restore_to_point_in_time"`

	S3Import []S3ImportParameters `json:"s3Import,omitempty" tf:"s3_import"`

	ScalingConfiguration []ScalingConfigurationParameters `json:"scalingConfiguration,omitempty" tf:"scaling_configuration"`

	SkipFinalSnapshot *bool `json:"skipFinalSnapshot,omitempty" tf:"skip_final_snapshot"`

	SnapshotIdentifier *string `json:"snapshotIdentifier,omitempty" tf:"snapshot_identifier"`

	SourceRegion *string `json:"sourceRegion,omitempty" tf:"source_region"`

	StorageEncrypted *bool `json:"storageEncrypted,omitempty" tf:"storage_encrypted"`

	Tags map[string]string `json:"tags,omitempty" tf:"tags"`

	TagsAll map[string]string `json:"tagsAll,omitempty" tf:"tags_all"`

	VpcSecurityGroupIds []string `json:"vpcSecurityGroupIds,omitempty" tf:"vpc_security_group_ids"`
}

type RestoreToPointInTimeObservation struct {
}

type RestoreToPointInTimeParameters struct {
	RestoreToTime *string `json:"restoreToTime,omitempty" tf:"restore_to_time"`

	RestoreType *string `json:"restoreType,omitempty" tf:"restore_type"`

	SourceClusterIdentifier string `json:"sourceClusterIdentifier" tf:"source_cluster_identifier"`

	UseLatestRestorableTime *bool `json:"useLatestRestorableTime,omitempty" tf:"use_latest_restorable_time"`
}

type S3ImportObservation struct {
}

type S3ImportParameters struct {
	BucketName string `json:"bucketName" tf:"bucket_name"`

	BucketPrefix *string `json:"bucketPrefix,omitempty" tf:"bucket_prefix"`

	IngestionRole string `json:"ingestionRole" tf:"ingestion_role"`

	SourceEngine string `json:"sourceEngine" tf:"source_engine"`

	SourceEngineVersion string `json:"sourceEngineVersion" tf:"source_engine_version"`
}

type ScalingConfigurationObservation struct {
}

type ScalingConfigurationParameters struct {
	AutoPause *bool `json:"autoPause,omitempty" tf:"auto_pause"`

	MaxCapacity *int64 `json:"maxCapacity,omitempty" tf:"max_capacity"`

	MinCapacity *int64 `json:"minCapacity,omitempty" tf:"min_capacity"`

	SecondsUntilAutoPause *int64 `json:"secondsUntilAutoPause,omitempty" tf:"seconds_until_auto_pause"`

	TimeoutAction *string `json:"timeoutAction,omitempty" tf:"timeout_action"`
}

// RdsClusterSpec defines the desired state of RdsCluster
type RdsClusterSpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       RdsClusterParameters `json:"forProvider"`
}

// RdsClusterStatus defines the observed state of RdsCluster.
type RdsClusterStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          RdsClusterObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// RdsCluster is the Schema for the RdsClusters API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,aws}
type RdsCluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              RdsClusterSpec   `json:"spec"`
	Status            RdsClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// RdsClusterList contains a list of RdsClusters
type RdsClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []RdsCluster `json:"items"`
}

// Repository type metadata.
var (
	RdsClusterKind             = "RdsCluster"
	RdsClusterGroupKind        = schema.GroupKind{Group: v1alpha1.Group, Kind: RdsClusterKind}.String()
	RdsClusterKindAPIVersion   = RdsClusterKind + "." + v1alpha1.GroupVersion.String()
	RdsClusterGroupVersionKind = v1alpha1.GroupVersion.WithKind(RdsClusterKind)
)

func init() {
	apis.SchemaMap[v1alpha1.GroupVersion] = append(apis.SchemaMap[v1alpha1.GroupVersion], &RdsCluster{}, &RdsClusterList{})
}
