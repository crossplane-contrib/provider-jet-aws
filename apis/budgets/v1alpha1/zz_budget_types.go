/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type BudgetObservation struct {
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`
}

type BudgetParameters struct {

	// +kubebuilder:validation:Optional
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	// +kubebuilder:validation:Required
	BudgetType *string `json:"budgetType" tf:"budget_type,omitempty"`

	// +kubebuilder:validation:Optional
	CostFilter []CostFilterParameters `json:"costFilter,omitempty" tf:"cost_filter,omitempty"`

	// +kubebuilder:validation:Optional
	CostFilters map[string]*string `json:"costFilters,omitempty" tf:"cost_filters,omitempty"`

	// +kubebuilder:validation:Optional
	CostTypes []CostTypesParameters `json:"costTypes,omitempty" tf:"cost_types,omitempty"`

	// +kubebuilder:validation:Required
	LimitAmount *string `json:"limitAmount" tf:"limit_amount,omitempty"`

	// +kubebuilder:validation:Required
	LimitUnit *string `json:"limitUnit" tf:"limit_unit,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	NamePrefix *string `json:"namePrefix,omitempty" tf:"name_prefix,omitempty"`

	// +kubebuilder:validation:Optional
	Notification []NotificationParameters `json:"notification,omitempty" tf:"notification,omitempty"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"-"`

	// +kubebuilder:validation:Optional
	TimePeriodEnd *string `json:"timePeriodEnd,omitempty" tf:"time_period_end,omitempty"`

	// +kubebuilder:validation:Optional
	TimePeriodStart *string `json:"timePeriodStart,omitempty" tf:"time_period_start,omitempty"`

	// +kubebuilder:validation:Required
	TimeUnit *string `json:"timeUnit" tf:"time_unit,omitempty"`
}

type CostFilterObservation struct {
}

type CostFilterParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Values []*string `json:"values" tf:"values,omitempty"`
}

type CostTypesObservation struct {
}

type CostTypesParameters struct {

	// +kubebuilder:validation:Optional
	IncludeCredit *bool `json:"includeCredit,omitempty" tf:"include_credit,omitempty"`

	// +kubebuilder:validation:Optional
	IncludeDiscount *bool `json:"includeDiscount,omitempty" tf:"include_discount,omitempty"`

	// +kubebuilder:validation:Optional
	IncludeOtherSubscription *bool `json:"includeOtherSubscription,omitempty" tf:"include_other_subscription,omitempty"`

	// +kubebuilder:validation:Optional
	IncludeRecurring *bool `json:"includeRecurring,omitempty" tf:"include_recurring,omitempty"`

	// +kubebuilder:validation:Optional
	IncludeRefund *bool `json:"includeRefund,omitempty" tf:"include_refund,omitempty"`

	// +kubebuilder:validation:Optional
	IncludeSubscription *bool `json:"includeSubscription,omitempty" tf:"include_subscription,omitempty"`

	// +kubebuilder:validation:Optional
	IncludeSupport *bool `json:"includeSupport,omitempty" tf:"include_support,omitempty"`

	// +kubebuilder:validation:Optional
	IncludeTax *bool `json:"includeTax,omitempty" tf:"include_tax,omitempty"`

	// +kubebuilder:validation:Optional
	IncludeUpfront *bool `json:"includeUpfront,omitempty" tf:"include_upfront,omitempty"`

	// +kubebuilder:validation:Optional
	UseAmortized *bool `json:"useAmortized,omitempty" tf:"use_amortized,omitempty"`

	// +kubebuilder:validation:Optional
	UseBlended *bool `json:"useBlended,omitempty" tf:"use_blended,omitempty"`
}

type NotificationObservation struct {
}

type NotificationParameters struct {

	// +kubebuilder:validation:Required
	ComparisonOperator *string `json:"comparisonOperator" tf:"comparison_operator,omitempty"`

	// +kubebuilder:validation:Required
	NotificationType *string `json:"notificationType" tf:"notification_type,omitempty"`

	// +kubebuilder:validation:Optional
	SubscriberEmailAddresses []*string `json:"subscriberEmailAddresses,omitempty" tf:"subscriber_email_addresses,omitempty"`

	// +kubebuilder:validation:Optional
	SubscriberSnsTopicArns []*string `json:"subscriberSnsTopicArns,omitempty" tf:"subscriber_sns_topic_arns,omitempty"`

	// +kubebuilder:validation:Required
	Threshold *float64 `json:"threshold" tf:"threshold,omitempty"`

	// +kubebuilder:validation:Required
	ThresholdType *string `json:"thresholdType" tf:"threshold_type,omitempty"`
}

// BudgetSpec defines the desired state of Budget
type BudgetSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     BudgetParameters `json:"forProvider"`
}

// BudgetStatus defines the observed state of Budget.
type BudgetStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        BudgetObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Budget is the Schema for the Budgets API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tfaws}
type Budget struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              BudgetSpec   `json:"spec"`
	Status            BudgetStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// BudgetList contains a list of Budgets
type BudgetList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Budget `json:"items"`
}

// Repository type metadata.
var (
	BudgetKind             = "Budget"
	BudgetGroupKind        = schema.GroupKind{Group: Group, Kind: BudgetKind}.String()
	BudgetKindAPIVersion   = BudgetKind + "." + GroupVersion.String()
	BudgetGroupVersionKind = GroupVersion.WithKind(BudgetKind)
)

func init() {
	SchemeBuilder.Register(&Budget{}, &BudgetList{})
}
