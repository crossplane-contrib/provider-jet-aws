/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type MetricAlarmObservation struct {
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	TagsAll map[string]*string `json:"tagsAll,omitempty" tf:"tags_all,omitempty"`
}

type MetricAlarmParameters struct {

	// +kubebuilder:validation:Optional
	ActionsEnabled *bool `json:"actionsEnabled,omitempty" tf:"actions_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	AlarmActions []*string `json:"alarmActions,omitempty" tf:"alarm_actions,omitempty"`

	// +kubebuilder:validation:Optional
	AlarmDescription *string `json:"alarmDescription,omitempty" tf:"alarm_description,omitempty"`

	// +kubebuilder:validation:Required
	AlarmName *string `json:"alarmName" tf:"alarm_name,omitempty"`

	// +kubebuilder:validation:Required
	ComparisonOperator *string `json:"comparisonOperator" tf:"comparison_operator,omitempty"`

	// +kubebuilder:validation:Optional
	DatapointsToAlarm *int64 `json:"datapointsToAlarm,omitempty" tf:"datapoints_to_alarm,omitempty"`

	// +kubebuilder:validation:Optional
	Dimensions map[string]*string `json:"dimensions,omitempty" tf:"dimensions,omitempty"`

	// +kubebuilder:validation:Optional
	EvaluateLowSampleCountPercentiles *string `json:"evaluateLowSampleCountPercentiles,omitempty" tf:"evaluate_low_sample_count_percentiles,omitempty"`

	// +kubebuilder:validation:Required
	EvaluationPeriods *int64 `json:"evaluationPeriods" tf:"evaluation_periods,omitempty"`

	// +kubebuilder:validation:Optional
	ExtendedStatistic *string `json:"extendedStatistic,omitempty" tf:"extended_statistic,omitempty"`

	// +kubebuilder:validation:Optional
	InsufficientDataActions []*string `json:"insufficientDataActions,omitempty" tf:"insufficient_data_actions,omitempty"`

	// +kubebuilder:validation:Optional
	MetricName *string `json:"metricName,omitempty" tf:"metric_name,omitempty"`

	// +kubebuilder:validation:Optional
	MetricQuery []MetricQueryParameters `json:"metricQuery,omitempty" tf:"metric_query,omitempty"`

	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// +kubebuilder:validation:Optional
	OkActions []*string `json:"okActions,omitempty" tf:"ok_actions,omitempty"`

	// +kubebuilder:validation:Optional
	Period *int64 `json:"period,omitempty" tf:"period,omitempty"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"-"`

	// +kubebuilder:validation:Optional
	Statistic *string `json:"statistic,omitempty" tf:"statistic,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Optional
	Threshold *float64 `json:"threshold,omitempty" tf:"threshold,omitempty"`

	// +kubebuilder:validation:Optional
	ThresholdMetricID *string `json:"thresholdMetricId,omitempty" tf:"threshold_metric_id,omitempty"`

	// +kubebuilder:validation:Optional
	TreatMissingData *string `json:"treatMissingData,omitempty" tf:"treat_missing_data,omitempty"`

	// +kubebuilder:validation:Optional
	Unit *string `json:"unit,omitempty" tf:"unit,omitempty"`
}

type MetricObservation struct {
}

type MetricParameters struct {

	// +kubebuilder:validation:Optional
	Dimensions map[string]*string `json:"dimensions,omitempty" tf:"dimensions,omitempty"`

	// +kubebuilder:validation:Required
	MetricName *string `json:"metricName" tf:"metric_name,omitempty"`

	// +kubebuilder:validation:Optional
	Namespace *string `json:"namespace,omitempty" tf:"namespace,omitempty"`

	// +kubebuilder:validation:Required
	Period *int64 `json:"period" tf:"period,omitempty"`

	// +kubebuilder:validation:Required
	Stat *string `json:"stat" tf:"stat,omitempty"`

	// +kubebuilder:validation:Optional
	Unit *string `json:"unit,omitempty" tf:"unit,omitempty"`
}

type MetricQueryObservation struct {
}

type MetricQueryParameters struct {

	// +kubebuilder:validation:Optional
	Expression *string `json:"expression,omitempty" tf:"expression,omitempty"`

	// +kubebuilder:validation:Required
	ID *string `json:"id" tf:"id,omitempty"`

	// +kubebuilder:validation:Optional
	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// +kubebuilder:validation:Optional
	Metric []MetricParameters `json:"metric,omitempty" tf:"metric,omitempty"`

	// +kubebuilder:validation:Optional
	ReturnData *bool `json:"returnData,omitempty" tf:"return_data,omitempty"`
}

// MetricAlarmSpec defines the desired state of MetricAlarm
type MetricAlarmSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     MetricAlarmParameters `json:"forProvider"`
}

// MetricAlarmStatus defines the observed state of MetricAlarm.
type MetricAlarmStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        MetricAlarmObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// MetricAlarm is the Schema for the MetricAlarms API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tfaws}
type MetricAlarm struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MetricAlarmSpec   `json:"spec"`
	Status            MetricAlarmStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MetricAlarmList contains a list of MetricAlarms
type MetricAlarmList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []MetricAlarm `json:"items"`
}

// Repository type metadata.
var (
	MetricAlarmKind             = "MetricAlarm"
	MetricAlarmGroupKind        = schema.GroupKind{Group: Group, Kind: MetricAlarmKind}.String()
	MetricAlarmKindAPIVersion   = MetricAlarmKind + "." + GroupVersion.String()
	MetricAlarmGroupVersionKind = GroupVersion.WithKind(MetricAlarmKind)
)

func init() {
	SchemeBuilder.Register(&MetricAlarm{}, &MetricAlarmList{})
}
