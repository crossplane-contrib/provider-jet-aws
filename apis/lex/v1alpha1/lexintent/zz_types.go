/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

// +kubebuilder:object:generate=true
// +groupName=lex.aws.tf.crossplane.io
// +versionName=v1alpha1

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1alpha1 "github.com/crossplane-contrib/provider-tf-aws/apis/lex/v1alpha1"
)

type CodeHookObservation struct {
}

type CodeHookParameters struct {
	MessageVersion string `json:"messageVersion" tf:"message_version"`

	Uri string `json:"uri" tf:"uri"`
}

type ConclusionStatementObservation struct {
}

type ConclusionStatementParameters struct {
	Message []MessageParameters `json:"message" tf:"message"`

	ResponseCard *string `json:"responseCard,omitempty" tf:"response_card"`
}

type ConfirmationPromptObservation struct {
}

type ConfirmationPromptParameters struct {
	MaxAttempts int64 `json:"maxAttempts" tf:"max_attempts"`

	Message []MessageParameters `json:"message" tf:"message"`

	ResponseCard *string `json:"responseCard,omitempty" tf:"response_card"`
}

type DialogCodeHookObservation struct {
}

type DialogCodeHookParameters struct {
	MessageVersion string `json:"messageVersion" tf:"message_version"`

	Uri string `json:"uri" tf:"uri"`
}

type FollowUpPromptObservation struct {
}

type FollowUpPromptParameters struct {
	Prompt []PromptParameters `json:"prompt" tf:"prompt"`

	RejectionStatement []RejectionStatementParameters `json:"rejectionStatement" tf:"rejection_statement"`
}

type FulfillmentActivityObservation struct {
}

type FulfillmentActivityParameters struct {
	CodeHook []CodeHookParameters `json:"codeHook,omitempty" tf:"code_hook"`

	Type string `json:"type" tf:"type"`
}

type LexIntentObservation struct {
	Arn string `json:"arn" tf:"arn"`

	Checksum string `json:"checksum" tf:"checksum"`

	CreatedDate string `json:"createdDate" tf:"created_date"`

	LastUpdatedDate string `json:"lastUpdatedDate" tf:"last_updated_date"`

	Version string `json:"version" tf:"version"`
}

type LexIntentParameters struct {
	ConclusionStatement []ConclusionStatementParameters `json:"conclusionStatement,omitempty" tf:"conclusion_statement"`

	ConfirmationPrompt []ConfirmationPromptParameters `json:"confirmationPrompt,omitempty" tf:"confirmation_prompt"`

	CreateVersion *bool `json:"createVersion,omitempty" tf:"create_version"`

	Description *string `json:"description,omitempty" tf:"description"`

	DialogCodeHook []DialogCodeHookParameters `json:"dialogCodeHook,omitempty" tf:"dialog_code_hook"`

	FollowUpPrompt []FollowUpPromptParameters `json:"followUpPrompt,omitempty" tf:"follow_up_prompt"`

	FulfillmentActivity []FulfillmentActivityParameters `json:"fulfillmentActivity" tf:"fulfillment_activity"`

	Name string `json:"name" tf:"name"`

	ParentIntentSignature *string `json:"parentIntentSignature,omitempty" tf:"parent_intent_signature"`

	RejectionStatement []RejectionStatementParameters `json:"rejectionStatement,omitempty" tf:"rejection_statement"`

	SampleUtterances []string `json:"sampleUtterances,omitempty" tf:"sample_utterances"`

	Slot []SlotParameters `json:"slot,omitempty" tf:"slot"`
}

type MessageObservation struct {
}

type MessageParameters struct {
	Content string `json:"content" tf:"content"`

	ContentType string `json:"contentType" tf:"content_type"`

	GroupNumber *int64 `json:"groupNumber,omitempty" tf:"group_number"`
}

type PromptObservation struct {
}

type PromptParameters struct {
	MaxAttempts int64 `json:"maxAttempts" tf:"max_attempts"`

	Message []MessageParameters `json:"message" tf:"message"`

	ResponseCard *string `json:"responseCard,omitempty" tf:"response_card"`
}

type RejectionStatementObservation struct {
}

type RejectionStatementParameters struct {
	Message []MessageParameters `json:"message" tf:"message"`

	ResponseCard *string `json:"responseCard,omitempty" tf:"response_card"`
}

type SlotObservation struct {
}

type SlotParameters struct {
	Description *string `json:"description,omitempty" tf:"description"`

	Name string `json:"name" tf:"name"`

	Priority *int64 `json:"priority,omitempty" tf:"priority"`

	ResponseCard *string `json:"responseCard,omitempty" tf:"response_card"`

	SampleUtterances []string `json:"sampleUtterances,omitempty" tf:"sample_utterances"`

	SlotConstraint string `json:"slotConstraint" tf:"slot_constraint"`

	SlotType string `json:"slotType" tf:"slot_type"`

	SlotTypeVersion *string `json:"slotTypeVersion,omitempty" tf:"slot_type_version"`

	ValueElicitationPrompt []ValueElicitationPromptParameters `json:"valueElicitationPrompt,omitempty" tf:"value_elicitation_prompt"`
}

type ValueElicitationPromptObservation struct {
}

type ValueElicitationPromptParameters struct {
	MaxAttempts int64 `json:"maxAttempts" tf:"max_attempts"`

	Message []MessageParameters `json:"message" tf:"message"`

	ResponseCard *string `json:"responseCard,omitempty" tf:"response_card"`
}

// LexIntentSpec defines the desired state of LexIntent
type LexIntentSpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       LexIntentParameters `json:"forProvider"`
}

// LexIntentStatus defines the observed state of LexIntent.
type LexIntentStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          LexIntentObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// LexIntent is the Schema for the LexIntents API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,aws}
type LexIntent struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              LexIntentSpec   `json:"spec"`
	Status            LexIntentStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// LexIntentList contains a list of LexIntents
type LexIntentList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []LexIntent `json:"items"`
}

// Repository type metadata.
var (
	LexIntentKind             = "LexIntent"
	LexIntentGroupKind        = schema.GroupKind{Group: v1alpha1.Group, Kind: LexIntentKind}.String()
	LexIntentKindAPIVersion   = LexIntentKind + "." + v1alpha1.GroupVersion.String()
	LexIntentGroupVersionKind = v1alpha1.GroupVersion.WithKind(LexIntentKind)
)

func init() {
	v1alpha1.SchemeBuilder.Register(&LexIntent{}, &LexIntentList{})
}
