/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ApplicationCodeConfigurationObservation struct {
}

type ApplicationCodeConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	CodeContent []CodeContentParameters `json:"codeContent,omitempty" tf:"code_content,omitempty"`

	// +kubebuilder:validation:Required
	CodeContentType *string `json:"codeContentType" tf:"code_content_type,omitempty"`
}

type ApplicationConfigurationObservation struct {
}

type ApplicationConfigurationParameters struct {

	// +kubebuilder:validation:Required
	ApplicationCodeConfiguration []ApplicationCodeConfigurationParameters `json:"applicationCodeConfiguration" tf:"application_code_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	ApplicationSnapshotConfiguration []ApplicationSnapshotConfigurationParameters `json:"applicationSnapshotConfiguration,omitempty" tf:"application_snapshot_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	EnvironmentProperties []EnvironmentPropertiesParameters `json:"environmentProperties,omitempty" tf:"environment_properties,omitempty"`

	// +kubebuilder:validation:Optional
	FlinkApplicationConfiguration []FlinkApplicationConfigurationParameters `json:"flinkApplicationConfiguration,omitempty" tf:"flink_application_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	RunConfiguration []RunConfigurationParameters `json:"runConfiguration,omitempty" tf:"run_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	SQLApplicationConfiguration []SQLApplicationConfigurationParameters `json:"sqlApplicationConfiguration,omitempty" tf:"sql_application_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	VpcConfiguration []VpcConfigurationParameters `json:"vpcConfiguration,omitempty" tf:"vpc_configuration,omitempty"`
}

type ApplicationObservation struct {
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	CreateTimestamp *string `json:"createTimestamp,omitempty" tf:"create_timestamp,omitempty"`

	LastUpdateTimestamp *string `json:"lastUpdateTimestamp,omitempty" tf:"last_update_timestamp,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	TagsAll map[string]*string `json:"tagsAll,omitempty" tf:"tags_all,omitempty"`

	VersionID *int64 `json:"versionId,omitempty" tf:"version_id,omitempty"`
}

type ApplicationParameters struct {

	// +kubebuilder:validation:Optional
	ApplicationConfiguration []ApplicationConfigurationParameters `json:"applicationConfiguration,omitempty" tf:"application_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	CloudwatchLoggingOptions []CloudwatchLoggingOptionsParameters `json:"cloudwatchLoggingOptions,omitempty" tf:"cloudwatch_logging_options,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	ForceStop *bool `json:"forceStop,omitempty" tf:"force_stop,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"-"`

	// +kubebuilder:validation:Required
	RuntimeEnvironment *string `json:"runtimeEnvironment" tf:"runtime_environment,omitempty"`

	// +kubebuilder:validation:Required
	ServiceExecutionRole *string `json:"serviceExecutionRole" tf:"service_execution_role,omitempty"`

	// +kubebuilder:validation:Optional
	StartApplication *bool `json:"startApplication,omitempty" tf:"start_application,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`
}

type ApplicationRestoreConfigurationObservation struct {
}

type ApplicationRestoreConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	ApplicationRestoreType *string `json:"applicationRestoreType,omitempty" tf:"application_restore_type,omitempty"`

	// +kubebuilder:validation:Optional
	SnapshotName *string `json:"snapshotName,omitempty" tf:"snapshot_name,omitempty"`
}

type ApplicationSnapshotConfigurationObservation struct {
}

type ApplicationSnapshotConfigurationParameters struct {

	// +kubebuilder:validation:Required
	SnapshotsEnabled *bool `json:"snapshotsEnabled" tf:"snapshots_enabled,omitempty"`
}

type CheckpointConfigurationObservation struct {
}

type CheckpointConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	CheckpointInterval *int64 `json:"checkpointInterval,omitempty" tf:"checkpoint_interval,omitempty"`

	// +kubebuilder:validation:Optional
	CheckpointingEnabled *bool `json:"checkpointingEnabled,omitempty" tf:"checkpointing_enabled,omitempty"`

	// +kubebuilder:validation:Required
	ConfigurationType *string `json:"configurationType" tf:"configuration_type,omitempty"`

	// +kubebuilder:validation:Optional
	MinPauseBetweenCheckpoints *int64 `json:"minPauseBetweenCheckpoints,omitempty" tf:"min_pause_between_checkpoints,omitempty"`
}

type CloudwatchLoggingOptionsObservation struct {
	CloudwatchLoggingOptionID *string `json:"cloudwatchLoggingOptionId,omitempty" tf:"cloudwatch_logging_option_id,omitempty"`
}

type CloudwatchLoggingOptionsParameters struct {

	// +kubebuilder:validation:Required
	LogStreamArn *string `json:"logStreamArn" tf:"log_stream_arn,omitempty"`
}

type CodeContentObservation struct {
}

type CodeContentParameters struct {

	// +kubebuilder:validation:Optional
	S3ContentLocation []S3ContentLocationParameters `json:"s3ContentLocation,omitempty" tf:"s3_content_location,omitempty"`

	// +kubebuilder:validation:Optional
	TextContent *string `json:"textContent,omitempty" tf:"text_content,omitempty"`
}

type CsvMappingParametersObservation struct {
}

type CsvMappingParametersParameters struct {

	// +kubebuilder:validation:Required
	RecordColumnDelimiter *string `json:"recordColumnDelimiter" tf:"record_column_delimiter,omitempty"`

	// +kubebuilder:validation:Required
	RecordRowDelimiter *string `json:"recordRowDelimiter" tf:"record_row_delimiter,omitempty"`
}

type DestinationSchemaObservation struct {
}

type DestinationSchemaParameters struct {

	// +kubebuilder:validation:Required
	RecordFormatType *string `json:"recordFormatType" tf:"record_format_type,omitempty"`
}

type EnvironmentPropertiesObservation struct {
}

type EnvironmentPropertiesParameters struct {

	// +kubebuilder:validation:Required
	PropertyGroup []PropertyGroupParameters `json:"propertyGroup" tf:"property_group,omitempty"`
}

type FlinkApplicationConfigurationObservation struct {
}

type FlinkApplicationConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	CheckpointConfiguration []CheckpointConfigurationParameters `json:"checkpointConfiguration,omitempty" tf:"checkpoint_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	MonitoringConfiguration []MonitoringConfigurationParameters `json:"monitoringConfiguration,omitempty" tf:"monitoring_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	ParallelismConfiguration []ParallelismConfigurationParameters `json:"parallelismConfiguration,omitempty" tf:"parallelism_configuration,omitempty"`
}

type FlinkRunConfigurationObservation struct {
}

type FlinkRunConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	AllowNonRestoredState *bool `json:"allowNonRestoredState,omitempty" tf:"allow_non_restored_state,omitempty"`
}

type InputLambdaProcessorObservation struct {
}

type InputLambdaProcessorParameters struct {

	// +kubebuilder:validation:Required
	ResourceArn *string `json:"resourceArn" tf:"resource_arn,omitempty"`
}

type InputObservation struct {
	InAppStreamNames []*string `json:"inAppStreamNames,omitempty" tf:"in_app_stream_names,omitempty"`

	InputID *string `json:"inputId,omitempty" tf:"input_id,omitempty"`
}

type InputParallelismObservation struct {
}

type InputParallelismParameters struct {

	// +kubebuilder:validation:Optional
	Count *int64 `json:"count,omitempty" tf:"count,omitempty"`
}

type InputParameters struct {

	// +kubebuilder:validation:Optional
	InputParallelism []InputParallelismParameters `json:"inputParallelism,omitempty" tf:"input_parallelism,omitempty"`

	// +kubebuilder:validation:Optional
	InputProcessingConfiguration []InputProcessingConfigurationParameters `json:"inputProcessingConfiguration,omitempty" tf:"input_processing_configuration,omitempty"`

	// +kubebuilder:validation:Required
	InputSchema []InputSchemaParameters `json:"inputSchema" tf:"input_schema,omitempty"`

	// +kubebuilder:validation:Optional
	InputStartingPositionConfiguration []InputStartingPositionConfigurationParameters `json:"inputStartingPositionConfiguration,omitempty" tf:"input_starting_position_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	KinesisFirehoseInput []KinesisFirehoseInputParameters `json:"kinesisFirehoseInput,omitempty" tf:"kinesis_firehose_input,omitempty"`

	// +kubebuilder:validation:Optional
	KinesisStreamsInput []KinesisStreamsInputParameters `json:"kinesisStreamsInput,omitempty" tf:"kinesis_streams_input,omitempty"`

	// +kubebuilder:validation:Required
	NamePrefix *string `json:"namePrefix" tf:"name_prefix,omitempty"`
}

type InputProcessingConfigurationObservation struct {
}

type InputProcessingConfigurationParameters struct {

	// +kubebuilder:validation:Required
	InputLambdaProcessor []InputLambdaProcessorParameters `json:"inputLambdaProcessor" tf:"input_lambda_processor,omitempty"`
}

type InputSchemaObservation struct {
}

type InputSchemaParameters struct {

	// +kubebuilder:validation:Required
	RecordColumn []RecordColumnParameters `json:"recordColumn" tf:"record_column,omitempty"`

	// +kubebuilder:validation:Optional
	RecordEncoding *string `json:"recordEncoding,omitempty" tf:"record_encoding,omitempty"`

	// +kubebuilder:validation:Required
	RecordFormat []RecordFormatParameters `json:"recordFormat" tf:"record_format,omitempty"`
}

type InputStartingPositionConfigurationObservation struct {
}

type InputStartingPositionConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	InputStartingPosition *string `json:"inputStartingPosition,omitempty" tf:"input_starting_position,omitempty"`
}

type JSONMappingParametersObservation struct {
}

type JSONMappingParametersParameters struct {

	// +kubebuilder:validation:Required
	RecordRowPath *string `json:"recordRowPath" tf:"record_row_path,omitempty"`
}

type KinesisFirehoseInputObservation struct {
}

type KinesisFirehoseInputParameters struct {

	// +kubebuilder:validation:Required
	ResourceArn *string `json:"resourceArn" tf:"resource_arn,omitempty"`
}

type KinesisFirehoseOutputObservation struct {
}

type KinesisFirehoseOutputParameters struct {

	// +kubebuilder:validation:Required
	ResourceArn *string `json:"resourceArn" tf:"resource_arn,omitempty"`
}

type KinesisStreamsInputObservation struct {
}

type KinesisStreamsInputParameters struct {

	// +kubebuilder:validation:Required
	ResourceArn *string `json:"resourceArn" tf:"resource_arn,omitempty"`
}

type KinesisStreamsOutputObservation struct {
}

type KinesisStreamsOutputParameters struct {

	// +kubebuilder:validation:Required
	ResourceArn *string `json:"resourceArn" tf:"resource_arn,omitempty"`
}

type LambdaOutputObservation struct {
}

type LambdaOutputParameters struct {

	// +kubebuilder:validation:Required
	ResourceArn *string `json:"resourceArn" tf:"resource_arn,omitempty"`
}

type MappingParametersCsvMappingParametersObservation struct {
}

type MappingParametersCsvMappingParametersParameters struct {

	// +kubebuilder:validation:Required
	RecordColumnDelimiter *string `json:"recordColumnDelimiter" tf:"record_column_delimiter,omitempty"`

	// +kubebuilder:validation:Required
	RecordRowDelimiter *string `json:"recordRowDelimiter" tf:"record_row_delimiter,omitempty"`
}

type MappingParametersJSONMappingParametersObservation struct {
}

type MappingParametersJSONMappingParametersParameters struct {

	// +kubebuilder:validation:Required
	RecordRowPath *string `json:"recordRowPath" tf:"record_row_path,omitempty"`
}

type MappingParametersObservation struct {
}

type MappingParametersParameters struct {

	// +kubebuilder:validation:Optional
	CsvMappingParameters []CsvMappingParametersParameters `json:"csvMappingParameters,omitempty" tf:"csv_mapping_parameters,omitempty"`

	// +kubebuilder:validation:Optional
	JSONMappingParameters []JSONMappingParametersParameters `json:"jsonMappingParameters,omitempty" tf:"json_mapping_parameters,omitempty"`
}

type MonitoringConfigurationObservation struct {
}

type MonitoringConfigurationParameters struct {

	// +kubebuilder:validation:Required
	ConfigurationType *string `json:"configurationType" tf:"configuration_type,omitempty"`

	// +kubebuilder:validation:Optional
	LogLevel *string `json:"logLevel,omitempty" tf:"log_level,omitempty"`

	// +kubebuilder:validation:Optional
	MetricsLevel *string `json:"metricsLevel,omitempty" tf:"metrics_level,omitempty"`
}

type OutputObservation struct {
	OutputID *string `json:"outputId,omitempty" tf:"output_id,omitempty"`
}

type OutputParameters struct {

	// +kubebuilder:validation:Required
	DestinationSchema []DestinationSchemaParameters `json:"destinationSchema" tf:"destination_schema,omitempty"`

	// +kubebuilder:validation:Optional
	KinesisFirehoseOutput []KinesisFirehoseOutputParameters `json:"kinesisFirehoseOutput,omitempty" tf:"kinesis_firehose_output,omitempty"`

	// +kubebuilder:validation:Optional
	KinesisStreamsOutput []KinesisStreamsOutputParameters `json:"kinesisStreamsOutput,omitempty" tf:"kinesis_streams_output,omitempty"`

	// +kubebuilder:validation:Optional
	LambdaOutput []LambdaOutputParameters `json:"lambdaOutput,omitempty" tf:"lambda_output,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

type ParallelismConfigurationObservation struct {
}

type ParallelismConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	AutoScalingEnabled *bool `json:"autoScalingEnabled,omitempty" tf:"auto_scaling_enabled,omitempty"`

	// +kubebuilder:validation:Required
	ConfigurationType *string `json:"configurationType" tf:"configuration_type,omitempty"`

	// +kubebuilder:validation:Optional
	Parallelism *int64 `json:"parallelism,omitempty" tf:"parallelism,omitempty"`

	// +kubebuilder:validation:Optional
	ParallelismPerKpu *int64 `json:"parallelismPerKpu,omitempty" tf:"parallelism_per_kpu,omitempty"`
}

type PropertyGroupObservation struct {
}

type PropertyGroupParameters struct {

	// +kubebuilder:validation:Required
	PropertyGroupID *string `json:"propertyGroupId" tf:"property_group_id,omitempty"`

	// +kubebuilder:validation:Required
	PropertyMap map[string]*string `json:"propertyMap" tf:"property_map,omitempty"`
}

type RecordColumnObservation struct {
}

type RecordColumnParameters struct {

	// +kubebuilder:validation:Optional
	Mapping *string `json:"mapping,omitempty" tf:"mapping,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	SQLType *string `json:"sqlType" tf:"sql_type,omitempty"`
}

type RecordFormatMappingParametersObservation struct {
}

type RecordFormatMappingParametersParameters struct {

	// +kubebuilder:validation:Optional
	CsvMappingParameters []MappingParametersCsvMappingParametersParameters `json:"csvMappingParameters,omitempty" tf:"csv_mapping_parameters,omitempty"`

	// +kubebuilder:validation:Optional
	JSONMappingParameters []MappingParametersJSONMappingParametersParameters `json:"jsonMappingParameters,omitempty" tf:"json_mapping_parameters,omitempty"`
}

type RecordFormatObservation struct {
}

type RecordFormatParameters struct {

	// +kubebuilder:validation:Required
	MappingParameters []MappingParametersParameters `json:"mappingParameters" tf:"mapping_parameters,omitempty"`

	// +kubebuilder:validation:Required
	RecordFormatType *string `json:"recordFormatType" tf:"record_format_type,omitempty"`
}

type ReferenceDataSourceObservation struct {
	ReferenceID *string `json:"referenceId,omitempty" tf:"reference_id,omitempty"`
}

type ReferenceDataSourceParameters struct {

	// +kubebuilder:validation:Required
	ReferenceSchema []ReferenceSchemaParameters `json:"referenceSchema" tf:"reference_schema,omitempty"`

	// +kubebuilder:validation:Required
	S3ReferenceDataSource []S3ReferenceDataSourceParameters `json:"s3ReferenceDataSource" tf:"s3_reference_data_source,omitempty"`

	// +kubebuilder:validation:Required
	TableName *string `json:"tableName" tf:"table_name,omitempty"`
}

type ReferenceSchemaObservation struct {
}

type ReferenceSchemaParameters struct {

	// +kubebuilder:validation:Required
	RecordColumn []ReferenceSchemaRecordColumnParameters `json:"recordColumn" tf:"record_column,omitempty"`

	// +kubebuilder:validation:Optional
	RecordEncoding *string `json:"recordEncoding,omitempty" tf:"record_encoding,omitempty"`

	// +kubebuilder:validation:Required
	RecordFormat []ReferenceSchemaRecordFormatParameters `json:"recordFormat" tf:"record_format,omitempty"`
}

type ReferenceSchemaRecordColumnObservation struct {
}

type ReferenceSchemaRecordColumnParameters struct {

	// +kubebuilder:validation:Optional
	Mapping *string `json:"mapping,omitempty" tf:"mapping,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	SQLType *string `json:"sqlType" tf:"sql_type,omitempty"`
}

type ReferenceSchemaRecordFormatObservation struct {
}

type ReferenceSchemaRecordFormatParameters struct {

	// +kubebuilder:validation:Required
	MappingParameters []RecordFormatMappingParametersParameters `json:"mappingParameters" tf:"mapping_parameters,omitempty"`

	// +kubebuilder:validation:Required
	RecordFormatType *string `json:"recordFormatType" tf:"record_format_type,omitempty"`
}

type RunConfigurationObservation struct {
}

type RunConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	ApplicationRestoreConfiguration []ApplicationRestoreConfigurationParameters `json:"applicationRestoreConfiguration,omitempty" tf:"application_restore_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	FlinkRunConfiguration []FlinkRunConfigurationParameters `json:"flinkRunConfiguration,omitempty" tf:"flink_run_configuration,omitempty"`
}

type S3ContentLocationObservation struct {
}

type S3ContentLocationParameters struct {

	// +kubebuilder:validation:Required
	BucketArn *string `json:"bucketArn" tf:"bucket_arn,omitempty"`

	// +kubebuilder:validation:Required
	FileKey *string `json:"fileKey" tf:"file_key,omitempty"`

	// +kubebuilder:validation:Optional
	ObjectVersion *string `json:"objectVersion,omitempty" tf:"object_version,omitempty"`
}

type S3ReferenceDataSourceObservation struct {
}

type S3ReferenceDataSourceParameters struct {

	// +kubebuilder:validation:Required
	BucketArn *string `json:"bucketArn" tf:"bucket_arn,omitempty"`

	// +kubebuilder:validation:Required
	FileKey *string `json:"fileKey" tf:"file_key,omitempty"`
}

type SQLApplicationConfigurationObservation struct {
}

type SQLApplicationConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	Input []InputParameters `json:"input,omitempty" tf:"input,omitempty"`

	// +kubebuilder:validation:Optional
	Output []OutputParameters `json:"output,omitempty" tf:"output,omitempty"`

	// +kubebuilder:validation:Optional
	ReferenceDataSource []ReferenceDataSourceParameters `json:"referenceDataSource,omitempty" tf:"reference_data_source,omitempty"`
}

type VpcConfigurationObservation struct {
	VpcConfigurationID *string `json:"vpcConfigurationId,omitempty" tf:"vpc_configuration_id,omitempty"`

	VpcID *string `json:"vpcId,omitempty" tf:"vpc_id,omitempty"`
}

type VpcConfigurationParameters struct {

	// +kubebuilder:validation:Required
	SecurityGroupIds []*string `json:"securityGroupIds" tf:"security_group_ids,omitempty"`

	// +kubebuilder:validation:Required
	SubnetIds []*string `json:"subnetIds" tf:"subnet_ids,omitempty"`
}

// ApplicationSpec defines the desired state of Application
type ApplicationSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ApplicationParameters `json:"forProvider"`
}

// ApplicationStatus defines the observed state of Application.
type ApplicationStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ApplicationObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Application is the Schema for the Applications API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tfaws}
type Application struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ApplicationSpec   `json:"spec"`
	Status            ApplicationStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ApplicationList contains a list of Applications
type ApplicationList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Application `json:"items"`
}

// Repository type metadata.
var (
	ApplicationKind             = "Application"
	ApplicationGroupKind        = schema.GroupKind{Group: Group, Kind: ApplicationKind}.String()
	ApplicationKindAPIVersion   = ApplicationKind + "." + GroupVersion.String()
	ApplicationGroupVersionKind = GroupVersion.WithKind(ApplicationKind)
)

func init() {
	SchemeBuilder.Register(&Application{}, &ApplicationList{})
}
