/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AddHeaderActionObservation struct {
}

type AddHeaderActionParameters struct {

	// +kubebuilder:validation:Required
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`

	// +kubebuilder:validation:Required
	HeaderValue *string `json:"headerValue" tf:"header_value,omitempty"`

	// +kubebuilder:validation:Required
	Position *int64 `json:"position" tf:"position,omitempty"`
}

type BounceActionObservation struct {
}

type BounceActionParameters struct {

	// +kubebuilder:validation:Required
	Message *string `json:"message" tf:"message,omitempty"`

	// +kubebuilder:validation:Required
	Position *int64 `json:"position" tf:"position,omitempty"`

	// +kubebuilder:validation:Required
	SMTPReplyCode *string `json:"smtpReplyCode" tf:"smtp_reply_code,omitempty"`

	// +kubebuilder:validation:Required
	Sender *string `json:"sender" tf:"sender,omitempty"`

	// +kubebuilder:validation:Optional
	StatusCode *string `json:"statusCode,omitempty" tf:"status_code,omitempty"`

	// +kubebuilder:validation:Optional
	TopicArn *string `json:"topicArn,omitempty" tf:"topic_arn,omitempty"`
}

type LambdaActionObservation struct {
}

type LambdaActionParameters struct {

	// +kubebuilder:validation:Required
	FunctionArn *string `json:"functionArn" tf:"function_arn,omitempty"`

	// +kubebuilder:validation:Optional
	InvocationType *string `json:"invocationType,omitempty" tf:"invocation_type,omitempty"`

	// +kubebuilder:validation:Required
	Position *int64 `json:"position" tf:"position,omitempty"`

	// +kubebuilder:validation:Optional
	TopicArn *string `json:"topicArn,omitempty" tf:"topic_arn,omitempty"`
}

type ReceiptRuleObservation struct {
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`
}

type ReceiptRuleParameters struct {

	// +kubebuilder:validation:Optional
	AddHeaderAction []AddHeaderActionParameters `json:"addHeaderAction,omitempty" tf:"add_header_action,omitempty"`

	// +kubebuilder:validation:Optional
	After *string `json:"after,omitempty" tf:"after,omitempty"`

	// +kubebuilder:validation:Optional
	BounceAction []BounceActionParameters `json:"bounceAction,omitempty" tf:"bounce_action,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Optional
	LambdaAction []LambdaActionParameters `json:"lambdaAction,omitempty" tf:"lambda_action,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Recipients []*string `json:"recipients,omitempty" tf:"recipients,omitempty"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"-"`

	// +kubebuilder:validation:Required
	RuleSetName *string `json:"ruleSetName" tf:"rule_set_name,omitempty"`

	// +kubebuilder:validation:Optional
	S3Action []S3ActionParameters `json:"s3Action,omitempty" tf:"s3_action,omitempty"`

	// +kubebuilder:validation:Optional
	ScanEnabled *bool `json:"scanEnabled,omitempty" tf:"scan_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	SnsAction []SnsActionParameters `json:"snsAction,omitempty" tf:"sns_action,omitempty"`

	// +kubebuilder:validation:Optional
	StopAction []StopActionParameters `json:"stopAction,omitempty" tf:"stop_action,omitempty"`

	// +kubebuilder:validation:Optional
	TLSPolicy *string `json:"tlsPolicy,omitempty" tf:"tls_policy,omitempty"`

	// +kubebuilder:validation:Optional
	WorkmailAction []WorkmailActionParameters `json:"workmailAction,omitempty" tf:"workmail_action,omitempty"`
}

type S3ActionObservation struct {
}

type S3ActionParameters struct {

	// +kubebuilder:validation:Required
	BucketName *string `json:"bucketName" tf:"bucket_name,omitempty"`

	// +kubebuilder:validation:Optional
	KmsKeyArn *string `json:"kmsKeyArn,omitempty" tf:"kms_key_arn,omitempty"`

	// +kubebuilder:validation:Optional
	ObjectKeyPrefix *string `json:"objectKeyPrefix,omitempty" tf:"object_key_prefix,omitempty"`

	// +kubebuilder:validation:Required
	Position *int64 `json:"position" tf:"position,omitempty"`

	// +kubebuilder:validation:Optional
	TopicArn *string `json:"topicArn,omitempty" tf:"topic_arn,omitempty"`
}

type SnsActionObservation struct {
}

type SnsActionParameters struct {

	// +kubebuilder:validation:Optional
	Encoding *string `json:"encoding,omitempty" tf:"encoding,omitempty"`

	// +kubebuilder:validation:Required
	Position *int64 `json:"position" tf:"position,omitempty"`

	// +kubebuilder:validation:Required
	TopicArn *string `json:"topicArn" tf:"topic_arn,omitempty"`
}

type StopActionObservation struct {
}

type StopActionParameters struct {

	// +kubebuilder:validation:Required
	Position *int64 `json:"position" tf:"position,omitempty"`

	// +kubebuilder:validation:Required
	Scope *string `json:"scope" tf:"scope,omitempty"`

	// +kubebuilder:validation:Optional
	TopicArn *string `json:"topicArn,omitempty" tf:"topic_arn,omitempty"`
}

type WorkmailActionObservation struct {
}

type WorkmailActionParameters struct {

	// +kubebuilder:validation:Required
	OrganizationArn *string `json:"organizationArn" tf:"organization_arn,omitempty"`

	// +kubebuilder:validation:Required
	Position *int64 `json:"position" tf:"position,omitempty"`

	// +kubebuilder:validation:Optional
	TopicArn *string `json:"topicArn,omitempty" tf:"topic_arn,omitempty"`
}

// ReceiptRuleSpec defines the desired state of ReceiptRule
type ReceiptRuleSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ReceiptRuleParameters `json:"forProvider"`
}

// ReceiptRuleStatus defines the observed state of ReceiptRule.
type ReceiptRuleStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ReceiptRuleObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// ReceiptRule is the Schema for the ReceiptRules API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tfaws}
type ReceiptRule struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ReceiptRuleSpec   `json:"spec"`
	Status            ReceiptRuleStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ReceiptRuleList contains a list of ReceiptRules
type ReceiptRuleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ReceiptRule `json:"items"`
}

// Repository type metadata.
var (
	ReceiptRuleKind             = "ReceiptRule"
	ReceiptRuleGroupKind        = schema.GroupKind{Group: Group, Kind: ReceiptRuleKind}.String()
	ReceiptRuleKindAPIVersion   = ReceiptRuleKind + "." + GroupVersion.String()
	ReceiptRuleGroupVersionKind = GroupVersion.WithKind(ReceiptRuleKind)
)

func init() {
	SchemeBuilder.Register(&ReceiptRule{}, &ReceiptRuleList{})
}
