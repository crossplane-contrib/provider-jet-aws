/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type BatchTargetObservation struct {
}

type BatchTargetParameters struct {

	// +kubebuilder:validation:Optional
	ArraySize *float64 `json:"arraySize,omitempty" tf:"array_size,omitempty"`

	// +kubebuilder:validation:Optional
	JobAttempts *float64 `json:"jobAttempts,omitempty" tf:"job_attempts,omitempty"`

	// +kubebuilder:validation:Required
	JobDefinition *string `json:"jobDefinition" tf:"job_definition,omitempty"`

	// +kubebuilder:validation:Required
	JobName *string `json:"jobName" tf:"job_name,omitempty"`
}

type DeadLetterConfigObservation struct {
}

type DeadLetterConfigParameters struct {

	// +kubebuilder:validation:Optional
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`
}

type EcsTargetObservation struct {
}

type EcsTargetParameters struct {

	// +kubebuilder:validation:Optional
	EnableEcsManagedTags *bool `json:"enableEcsManagedTags,omitempty" tf:"enable_ecs_managed_tags,omitempty"`

	// +kubebuilder:validation:Optional
	EnableExecuteCommand *bool `json:"enableExecuteCommand,omitempty" tf:"enable_execute_command,omitempty"`

	// +kubebuilder:validation:Optional
	Group *string `json:"group,omitempty" tf:"group,omitempty"`

	// +kubebuilder:validation:Optional
	LaunchType *string `json:"launchType,omitempty" tf:"launch_type,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkConfiguration []NetworkConfigurationParameters `json:"networkConfiguration,omitempty" tf:"network_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	PlacementConstraint []PlacementConstraintParameters `json:"placementConstraint,omitempty" tf:"placement_constraint,omitempty"`

	// +kubebuilder:validation:Optional
	PlatformVersion *string `json:"platformVersion,omitempty" tf:"platform_version,omitempty"`

	// +kubebuilder:validation:Optional
	PropagateTags *string `json:"propagateTags,omitempty" tf:"propagate_tags,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Optional
	TaskCount *float64 `json:"taskCount,omitempty" tf:"task_count,omitempty"`

	// +kubebuilder:validation:Required
	TaskDefinitionArn *string `json:"taskDefinitionArn" tf:"task_definition_arn,omitempty"`
}

type HTTPTargetObservation struct {
}

type HTTPTargetParameters struct {

	// +kubebuilder:validation:Optional
	HeaderParameters map[string]*string `json:"headerParameters,omitempty" tf:"header_parameters,omitempty"`

	// +kubebuilder:validation:Optional
	PathParameterValues []*string `json:"pathParameterValues,omitempty" tf:"path_parameter_values,omitempty"`

	// +kubebuilder:validation:Optional
	QueryStringParameters map[string]*string `json:"queryStringParameters,omitempty" tf:"query_string_parameters,omitempty"`
}

type InputTransformerObservation struct {
}

type InputTransformerParameters struct {

	// +kubebuilder:validation:Optional
	InputPaths map[string]*string `json:"inputPaths,omitempty" tf:"input_paths,omitempty"`

	// +kubebuilder:validation:Required
	InputTemplate *string `json:"inputTemplate" tf:"input_template,omitempty"`
}

type KinesisTargetObservation struct {
}

type KinesisTargetParameters struct {

	// +kubebuilder:validation:Optional
	PartitionKeyPath *string `json:"partitionKeyPath,omitempty" tf:"partition_key_path,omitempty"`
}

type NetworkConfigurationObservation struct {
}

type NetworkConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	AssignPublicIP *bool `json:"assignPublicIp,omitempty" tf:"assign_public_ip,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityGroups []*string `json:"securityGroups,omitempty" tf:"security_groups,omitempty"`

	// +kubebuilder:validation:Required
	Subnets []*string `json:"subnets" tf:"subnets,omitempty"`
}

type PlacementConstraintObservation struct {
}

type PlacementConstraintParameters struct {

	// +kubebuilder:validation:Optional
	Expression *string `json:"expression,omitempty" tf:"expression,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type RedshiftTargetObservation struct {
}

type RedshiftTargetParameters struct {

	// +kubebuilder:validation:Optional
	DBUser *string `json:"dbUser,omitempty" tf:"db_user,omitempty"`

	// +kubebuilder:validation:Required
	Database *string `json:"database" tf:"database,omitempty"`

	// +kubebuilder:validation:Optional
	SQL *string `json:"sql,omitempty" tf:"sql,omitempty"`

	// +kubebuilder:validation:Optional
	SecretsManagerArn *string `json:"secretsManagerArn,omitempty" tf:"secrets_manager_arn,omitempty"`

	// +kubebuilder:validation:Optional
	StatementName *string `json:"statementName,omitempty" tf:"statement_name,omitempty"`

	// +kubebuilder:validation:Optional
	WithEvent *bool `json:"withEvent,omitempty" tf:"with_event,omitempty"`
}

type RetryPolicyObservation struct {
}

type RetryPolicyParameters struct {

	// +kubebuilder:validation:Optional
	MaximumEventAgeInSeconds *float64 `json:"maximumEventAgeInSeconds,omitempty" tf:"maximum_event_age_in_seconds,omitempty"`

	// +kubebuilder:validation:Optional
	MaximumRetryAttempts *float64 `json:"maximumRetryAttempts,omitempty" tf:"maximum_retry_attempts,omitempty"`
}

type RunCommandTargetsObservation struct {
}

type RunCommandTargetsParameters struct {

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Required
	Values []*string `json:"values" tf:"values,omitempty"`
}

type SqsTargetObservation struct {
}

type SqsTargetParameters struct {

	// +kubebuilder:validation:Optional
	MessageGroupID *string `json:"messageGroupId,omitempty" tf:"message_group_id,omitempty"`
}

type TargetObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type TargetParameters struct {

	// +kubebuilder:validation:Required
	Arn *string `json:"arn" tf:"arn,omitempty"`

	// +kubebuilder:validation:Optional
	BatchTarget []BatchTargetParameters `json:"batchTarget,omitempty" tf:"batch_target,omitempty"`

	// +kubebuilder:validation:Optional
	DeadLetterConfig []DeadLetterConfigParameters `json:"deadLetterConfig,omitempty" tf:"dead_letter_config,omitempty"`

	// +kubebuilder:validation:Optional
	EcsTarget []EcsTargetParameters `json:"ecsTarget,omitempty" tf:"ecs_target,omitempty"`

	// +kubebuilder:validation:Optional
	EventBusName *string `json:"eventBusName,omitempty" tf:"event_bus_name,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPTarget []HTTPTargetParameters `json:"httpTarget,omitempty" tf:"http_target,omitempty"`

	// +kubebuilder:validation:Optional
	Input *string `json:"input,omitempty" tf:"input,omitempty"`

	// +kubebuilder:validation:Optional
	InputPath *string `json:"inputPath,omitempty" tf:"input_path,omitempty"`

	// +kubebuilder:validation:Optional
	InputTransformer []InputTransformerParameters `json:"inputTransformer,omitempty" tf:"input_transformer,omitempty"`

	// +kubebuilder:validation:Optional
	KinesisTarget []KinesisTargetParameters `json:"kinesisTarget,omitempty" tf:"kinesis_target,omitempty"`

	// +kubebuilder:validation:Optional
	RedshiftTarget []RedshiftTargetParameters `json:"redshiftTarget,omitempty" tf:"redshift_target,omitempty"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"-"`

	// +kubebuilder:validation:Optional
	RetryPolicy []RetryPolicyParameters `json:"retryPolicy,omitempty" tf:"retry_policy,omitempty"`

	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-jet-aws/apis/iam/v1alpha2.Role
	// +crossplane:generate:reference:extractor=github.com/crossplane-contrib/provider-jet-aws/config/common.ARNExtractor()
	// +kubebuilder:validation:Optional
	RoleArn *string `json:"roleArn,omitempty" tf:"role_arn,omitempty"`

	// +kubebuilder:validation:Optional
	RoleArnRef *v1.Reference `json:"roleArnRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	RoleArnSelector *v1.Selector `json:"roleArnSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Required
	Rule *string `json:"rule" tf:"rule,omitempty"`

	// +kubebuilder:validation:Optional
	RunCommandTargets []RunCommandTargetsParameters `json:"runCommandTargets,omitempty" tf:"run_command_targets,omitempty"`

	// +kubebuilder:validation:Optional
	SqsTarget []SqsTargetParameters `json:"sqsTarget,omitempty" tf:"sqs_target,omitempty"`

	// +kubebuilder:validation:Optional
	TargetID *string `json:"targetId,omitempty" tf:"target_id,omitempty"`
}

// TargetSpec defines the desired state of Target
type TargetSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     TargetParameters `json:"forProvider"`
}

// TargetStatus defines the observed state of Target.
type TargetStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        TargetObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Target is the Schema for the Targets API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,awsjet}
type Target struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              TargetSpec   `json:"spec"`
	Status            TargetStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// TargetList contains a list of Targets
type TargetList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Target `json:"items"`
}

// Repository type metadata.
var (
	Target_Kind             = "Target"
	Target_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Target_Kind}.String()
	Target_KindAPIVersion   = Target_Kind + "." + CRDGroupVersion.String()
	Target_GroupVersionKind = CRDGroupVersion.WithKind(Target_Kind)
)

func init() {
	SchemeBuilder.Register(&Target{}, &TargetList{})
}
