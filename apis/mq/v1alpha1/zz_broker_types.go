/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type BrokerObservation struct {
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	Instances []InstancesObservation `json:"instances,omitempty" tf:"instances,omitempty"`

	TagsAll map[string]*string `json:"tagsAll,omitempty" tf:"tags_all,omitempty"`
}

type BrokerParameters struct {

	// +kubebuilder:validation:Optional
	ApplyImmediately *bool `json:"applyImmediately,omitempty" tf:"apply_immediately,omitempty"`

	// +kubebuilder:validation:Optional
	AuthenticationStrategy *string `json:"authenticationStrategy,omitempty" tf:"authentication_strategy,omitempty"`

	// +kubebuilder:validation:Optional
	AutoMinorVersionUpgrade *bool `json:"autoMinorVersionUpgrade,omitempty" tf:"auto_minor_version_upgrade,omitempty"`

	// +kubebuilder:validation:Required
	BrokerName *string `json:"brokerName" tf:"broker_name,omitempty"`

	// +kubebuilder:validation:Optional
	Configuration []ConfigurationParameters `json:"configuration,omitempty" tf:"configuration,omitempty"`

	// +kubebuilder:validation:Optional
	DeploymentMode *string `json:"deploymentMode,omitempty" tf:"deployment_mode,omitempty"`

	// +kubebuilder:validation:Optional
	EncryptionOptions []EncryptionOptionsParameters `json:"encryptionOptions,omitempty" tf:"encryption_options,omitempty"`

	// +kubebuilder:validation:Required
	EngineType *string `json:"engineType" tf:"engine_type,omitempty"`

	// +kubebuilder:validation:Required
	EngineVersion *string `json:"engineVersion" tf:"engine_version,omitempty"`

	// +kubebuilder:validation:Required
	HostInstanceType *string `json:"hostInstanceType" tf:"host_instance_type,omitempty"`

	// +kubebuilder:validation:Optional
	LdapServerMetadata []LdapServerMetadataParameters `json:"ldapServerMetadata,omitempty" tf:"ldap_server_metadata,omitempty"`

	// +kubebuilder:validation:Optional
	Logs []LogsParameters `json:"logs,omitempty" tf:"logs,omitempty"`

	// +kubebuilder:validation:Optional
	MaintenanceWindowStartTime []MaintenanceWindowStartTimeParameters `json:"maintenanceWindowStartTime,omitempty" tf:"maintenance_window_start_time,omitempty"`

	// +kubebuilder:validation:Optional
	PubliclyAccessible *bool `json:"publiclyAccessible,omitempty" tf:"publicly_accessible,omitempty"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"-"`

	// +kubebuilder:validation:Optional
	SecurityGroups []*string `json:"securityGroups,omitempty" tf:"security_groups,omitempty"`

	// +kubebuilder:validation:Optional
	StorageType *string `json:"storageType,omitempty" tf:"storage_type,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetIds []*string `json:"subnetIds,omitempty" tf:"subnet_ids,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Required
	User []UserParameters `json:"user" tf:"user,omitempty"`
}

type ConfigurationObservation struct {
}

type ConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// +kubebuilder:validation:Optional
	Revision *int64 `json:"revision,omitempty" tf:"revision,omitempty"`
}

type EncryptionOptionsObservation struct {
}

type EncryptionOptionsParameters struct {

	// +kubebuilder:validation:Optional
	KmsKeyID *string `json:"kmsKeyId,omitempty" tf:"kms_key_id,omitempty"`

	// +kubebuilder:validation:Optional
	UseAwsOwnedKey *bool `json:"useAwsOwnedKey,omitempty" tf:"use_aws_owned_key,omitempty"`
}

type InstancesObservation struct {
	ConsoleURL *string `json:"consoleUrl,omitempty" tf:"console_url,omitempty"`

	Endpoints []*string `json:"endpoints,omitempty" tf:"endpoints,omitempty"`

	IPAddress *string `json:"ipAddress,omitempty" tf:"ip_address,omitempty"`
}

type InstancesParameters struct {
}

type LdapServerMetadataObservation struct {
}

type LdapServerMetadataParameters struct {

	// +kubebuilder:validation:Optional
	Hosts []*string `json:"hosts,omitempty" tf:"hosts,omitempty"`

	// +kubebuilder:validation:Optional
	RoleBase *string `json:"roleBase,omitempty" tf:"role_base,omitempty"`

	// +kubebuilder:validation:Optional
	RoleName *string `json:"roleName,omitempty" tf:"role_name,omitempty"`

	// +kubebuilder:validation:Optional
	RoleSearchMatching *string `json:"roleSearchMatching,omitempty" tf:"role_search_matching,omitempty"`

	// +kubebuilder:validation:Optional
	RoleSearchSubtree *bool `json:"roleSearchSubtree,omitempty" tf:"role_search_subtree,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceAccountPasswordSecretRef v1.SecretKeySelector `json:"serviceAccountPasswordSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ServiceAccountUsername *string `json:"serviceAccountUsername,omitempty" tf:"service_account_username,omitempty"`

	// +kubebuilder:validation:Optional
	UserBase *string `json:"userBase,omitempty" tf:"user_base,omitempty"`

	// +kubebuilder:validation:Optional
	UserRoleName *string `json:"userRoleName,omitempty" tf:"user_role_name,omitempty"`

	// +kubebuilder:validation:Optional
	UserSearchMatching *string `json:"userSearchMatching,omitempty" tf:"user_search_matching,omitempty"`

	// +kubebuilder:validation:Optional
	UserSearchSubtree *bool `json:"userSearchSubtree,omitempty" tf:"user_search_subtree,omitempty"`
}

type LogsObservation struct {
}

type LogsParameters struct {

	// +kubebuilder:validation:Optional
	Audit *string `json:"audit,omitempty" tf:"audit,omitempty"`

	// +kubebuilder:validation:Optional
	General *bool `json:"general,omitempty" tf:"general,omitempty"`
}

type MaintenanceWindowStartTimeObservation struct {
}

type MaintenanceWindowStartTimeParameters struct {

	// +kubebuilder:validation:Required
	DayOfWeek *string `json:"dayOfWeek" tf:"day_of_week,omitempty"`

	// +kubebuilder:validation:Required
	TimeOfDay *string `json:"timeOfDay" tf:"time_of_day,omitempty"`

	// +kubebuilder:validation:Required
	TimeZone *string `json:"timeZone" tf:"time_zone,omitempty"`
}

type UserObservation struct {
}

type UserParameters struct {

	// +kubebuilder:validation:Optional
	ConsoleAccess *bool `json:"consoleAccess,omitempty" tf:"console_access,omitempty"`

	// +kubebuilder:validation:Optional
	Groups []*string `json:"groups,omitempty" tf:"groups,omitempty"`

	// +kubebuilder:validation:Required
	PasswordSecretRef v1.SecretKeySelector `json:"passwordSecretRef" tf:"-"`

	// +kubebuilder:validation:Required
	Username *string `json:"username" tf:"username,omitempty"`
}

// BrokerSpec defines the desired state of Broker
type BrokerSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     BrokerParameters `json:"forProvider"`
}

// BrokerStatus defines the observed state of Broker.
type BrokerStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        BrokerObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Broker is the Schema for the Brokers API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tfaws}
type Broker struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              BrokerSpec   `json:"spec"`
	Status            BrokerStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// BrokerList contains a list of Brokers
type BrokerList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Broker `json:"items"`
}

// Repository type metadata.
var (
	BrokerKind             = "Broker"
	BrokerGroupKind        = schema.GroupKind{Group: Group, Kind: BrokerKind}.String()
	BrokerKindAPIVersion   = BrokerKind + "." + GroupVersion.String()
	BrokerGroupVersionKind = GroupVersion.WithKind(BrokerKind)
)

func init() {
	SchemeBuilder.Register(&Broker{}, &BrokerList{})
}
