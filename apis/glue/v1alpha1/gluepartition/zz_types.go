/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

// +kubebuilder:object:generate=true
// +groupName=glue.aws.tf.crossplane.io
// +versionName=v1alpha1

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1alpha1 "github.com/crossplane-contrib/provider-tf-aws/apis/glue/v1alpha1"
)

type ColumnsObservation struct {
}

type ColumnsParameters struct {
	Comment *string `json:"comment,omitempty" tf:"comment"`

	Name string `json:"name" tf:"name"`

	Type *string `json:"type,omitempty" tf:"type"`
}

type GluePartitionObservation struct {
	CreationTime string `json:"creationTime" tf:"creation_time"`

	LastAccessedTime string `json:"lastAccessedTime" tf:"last_accessed_time"`

	LastAnalyzedTime string `json:"lastAnalyzedTime" tf:"last_analyzed_time"`
}

type GluePartitionParameters struct {
	CatalogId *string `json:"catalogId,omitempty" tf:"catalog_id"`

	DatabaseName string `json:"databaseName" tf:"database_name"`

	Parameters map[string]string `json:"parameters,omitempty" tf:"parameters"`

	PartitionValues []string `json:"partitionValues" tf:"partition_values"`

	StorageDescriptor []StorageDescriptorParameters `json:"storageDescriptor,omitempty" tf:"storage_descriptor"`

	TableName string `json:"tableName" tf:"table_name"`
}

type SerDeInfoObservation struct {
}

type SerDeInfoParameters struct {
	Name *string `json:"name,omitempty" tf:"name"`

	Parameters map[string]string `json:"parameters,omitempty" tf:"parameters"`

	SerializationLibrary *string `json:"serializationLibrary,omitempty" tf:"serialization_library"`
}

type SkewedInfoObservation struct {
}

type SkewedInfoParameters struct {
	SkewedColumnNames []string `json:"skewedColumnNames,omitempty" tf:"skewed_column_names"`

	SkewedColumnValueLocationMaps map[string]string `json:"skewedColumnValueLocationMaps,omitempty" tf:"skewed_column_value_location_maps"`

	SkewedColumnValues []string `json:"skewedColumnValues,omitempty" tf:"skewed_column_values"`
}

type SortColumnsObservation struct {
}

type SortColumnsParameters struct {
	Column string `json:"column" tf:"column"`

	SortOrder int64 `json:"sortOrder" tf:"sort_order"`
}

type StorageDescriptorObservation struct {
}

type StorageDescriptorParameters struct {
	BucketColumns []string `json:"bucketColumns,omitempty" tf:"bucket_columns"`

	Columns []ColumnsParameters `json:"columns,omitempty" tf:"columns"`

	Compressed *bool `json:"compressed,omitempty" tf:"compressed"`

	InputFormat *string `json:"inputFormat,omitempty" tf:"input_format"`

	Location *string `json:"location,omitempty" tf:"location"`

	NumberOfBuckets *int64 `json:"numberOfBuckets,omitempty" tf:"number_of_buckets"`

	OutputFormat *string `json:"outputFormat,omitempty" tf:"output_format"`

	Parameters map[string]string `json:"parameters,omitempty" tf:"parameters"`

	SerDeInfo []SerDeInfoParameters `json:"serDeInfo,omitempty" tf:"ser_de_info"`

	SkewedInfo []SkewedInfoParameters `json:"skewedInfo,omitempty" tf:"skewed_info"`

	SortColumns []SortColumnsParameters `json:"sortColumns,omitempty" tf:"sort_columns"`

	StoredAsSubDirectories *bool `json:"storedAsSubDirectories,omitempty" tf:"stored_as_sub_directories"`
}

// GluePartitionSpec defines the desired state of GluePartition
type GluePartitionSpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       GluePartitionParameters `json:"forProvider"`
}

// GluePartitionStatus defines the observed state of GluePartition.
type GluePartitionStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          GluePartitionObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// GluePartition is the Schema for the GluePartitions API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,aws}
type GluePartition struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              GluePartitionSpec   `json:"spec"`
	Status            GluePartitionStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// GluePartitionList contains a list of GluePartitions
type GluePartitionList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []GluePartition `json:"items"`
}

// Repository type metadata.
var (
	GluePartitionKind             = "GluePartition"
	GluePartitionGroupKind        = schema.GroupKind{Group: v1alpha1.Group, Kind: GluePartitionKind}.String()
	GluePartitionKindAPIVersion   = GluePartitionKind + "." + v1alpha1.GroupVersion.String()
	GluePartitionGroupVersionKind = v1alpha1.GroupVersion.WithKind(GluePartitionKind)
)

func init() {
	v1alpha1.SchemeBuilder.Register(&GluePartition{}, &GluePartitionList{})
}
