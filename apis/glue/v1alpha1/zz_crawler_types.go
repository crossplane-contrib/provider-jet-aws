/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type CatalogTargetObservation struct {
}

type CatalogTargetParameters struct {

	// +kubebuilder:validation:Required
	DatabaseName *string `json:"databaseName" tf:"database_name,omitempty"`

	// +kubebuilder:validation:Required
	Tables []*string `json:"tables" tf:"tables,omitempty"`
}

type CrawlerObservation struct {
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	TagsAll map[string]*string `json:"tagsAll,omitempty" tf:"tags_all,omitempty"`
}

type CrawlerParameters struct {

	// +kubebuilder:validation:Optional
	CatalogTarget []CatalogTargetParameters `json:"catalogTarget,omitempty" tf:"catalog_target,omitempty"`

	// +kubebuilder:validation:Optional
	Classifiers []*string `json:"classifiers,omitempty" tf:"classifiers,omitempty"`

	// +kubebuilder:validation:Optional
	Configuration *string `json:"configuration,omitempty" tf:"configuration,omitempty"`

	// +kubebuilder:validation:Required
	DatabaseName *string `json:"databaseName" tf:"database_name,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	DynamodbTarget []DynamodbTargetParameters `json:"dynamodbTarget,omitempty" tf:"dynamodb_target,omitempty"`

	// +kubebuilder:validation:Optional
	JdbcTarget []JdbcTargetParameters `json:"jdbcTarget,omitempty" tf:"jdbc_target,omitempty"`

	// +kubebuilder:validation:Optional
	LineageConfiguration []LineageConfigurationParameters `json:"lineageConfiguration,omitempty" tf:"lineage_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	MongodbTarget []MongodbTargetParameters `json:"mongodbTarget,omitempty" tf:"mongodb_target,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	RecrawlPolicy []RecrawlPolicyParameters `json:"recrawlPolicy,omitempty" tf:"recrawl_policy,omitempty"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"-"`

	// +kubebuilder:validation:Required
	Role *string `json:"role" tf:"role,omitempty"`

	// +kubebuilder:validation:Optional
	S3Target []S3TargetParameters `json:"s3Target,omitempty" tf:"s3_target,omitempty"`

	// +kubebuilder:validation:Optional
	Schedule *string `json:"schedule,omitempty" tf:"schedule,omitempty"`

	// +kubebuilder:validation:Optional
	SchemaChangePolicy []SchemaChangePolicyParameters `json:"schemaChangePolicy,omitempty" tf:"schema_change_policy,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityConfiguration *string `json:"securityConfiguration,omitempty" tf:"security_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	TablePrefix *string `json:"tablePrefix,omitempty" tf:"table_prefix,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`
}

type DynamodbTargetObservation struct {
}

type DynamodbTargetParameters struct {

	// +kubebuilder:validation:Required
	Path *string `json:"path" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	ScanAll *bool `json:"scanAll,omitempty" tf:"scan_all,omitempty"`

	// +kubebuilder:validation:Optional
	ScanRate *float64 `json:"scanRate,omitempty" tf:"scan_rate,omitempty"`
}

type JdbcTargetObservation struct {
}

type JdbcTargetParameters struct {

	// +kubebuilder:validation:Required
	ConnectionName *string `json:"connectionName" tf:"connection_name,omitempty"`

	// +kubebuilder:validation:Optional
	Exclusions []*string `json:"exclusions,omitempty" tf:"exclusions,omitempty"`

	// +kubebuilder:validation:Required
	Path *string `json:"path" tf:"path,omitempty"`
}

type LineageConfigurationObservation struct {
}

type LineageConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	CrawlerLineageSettings *string `json:"crawlerLineageSettings,omitempty" tf:"crawler_lineage_settings,omitempty"`
}

type MongodbTargetObservation struct {
}

type MongodbTargetParameters struct {

	// +kubebuilder:validation:Required
	ConnectionName *string `json:"connectionName" tf:"connection_name,omitempty"`

	// +kubebuilder:validation:Required
	Path *string `json:"path" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	ScanAll *bool `json:"scanAll,omitempty" tf:"scan_all,omitempty"`
}

type RecrawlPolicyObservation struct {
}

type RecrawlPolicyParameters struct {

	// +kubebuilder:validation:Optional
	RecrawlBehavior *string `json:"recrawlBehavior,omitempty" tf:"recrawl_behavior,omitempty"`
}

type S3TargetObservation struct {
}

type S3TargetParameters struct {

	// +kubebuilder:validation:Optional
	ConnectionName *string `json:"connectionName,omitempty" tf:"connection_name,omitempty"`

	// +kubebuilder:validation:Optional
	Exclusions []*string `json:"exclusions,omitempty" tf:"exclusions,omitempty"`

	// +kubebuilder:validation:Required
	Path *string `json:"path" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	SampleSize *int64 `json:"sampleSize,omitempty" tf:"sample_size,omitempty"`
}

type SchemaChangePolicyObservation struct {
}

type SchemaChangePolicyParameters struct {

	// +kubebuilder:validation:Optional
	DeleteBehavior *string `json:"deleteBehavior,omitempty" tf:"delete_behavior,omitempty"`

	// +kubebuilder:validation:Optional
	UpdateBehavior *string `json:"updateBehavior,omitempty" tf:"update_behavior,omitempty"`
}

// CrawlerSpec defines the desired state of Crawler
type CrawlerSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     CrawlerParameters `json:"forProvider"`
}

// CrawlerStatus defines the observed state of Crawler.
type CrawlerStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        CrawlerObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Crawler is the Schema for the Crawlers API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tfaws}
type Crawler struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              CrawlerSpec   `json:"spec"`
	Status            CrawlerStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// CrawlerList contains a list of Crawlers
type CrawlerList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Crawler `json:"items"`
}

// Repository type metadata.
var (
	CrawlerKind             = "Crawler"
	CrawlerGroupKind        = schema.GroupKind{Group: Group, Kind: CrawlerKind}.String()
	CrawlerKindAPIVersion   = CrawlerKind + "." + GroupVersion.String()
	CrawlerGroupVersionKind = GroupVersion.WithKind(CrawlerKind)
)

func init() {
	SchemeBuilder.Register(&Crawler{}, &CrawlerList{})
}
