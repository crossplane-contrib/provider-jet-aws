/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type FindMatchesParametersObservation struct {
}

type FindMatchesParametersParameters struct {

	// +kubebuilder:validation:Optional
	AccuracyCostTradeOff *float64 `json:"accuracyCostTradeOff,omitempty" tf:"accuracy_cost_trade_off,omitempty"`

	// +kubebuilder:validation:Optional
	EnforceProvidedLabels *bool `json:"enforceProvidedLabels,omitempty" tf:"enforce_provided_labels,omitempty"`

	// +kubebuilder:validation:Optional
	PrecisionRecallTradeOff *float64 `json:"precisionRecallTradeOff,omitempty" tf:"precision_recall_trade_off,omitempty"`

	// +kubebuilder:validation:Optional
	PrimaryKeyColumnName *string `json:"primaryKeyColumnName,omitempty" tf:"primary_key_column_name,omitempty"`
}

type InputRecordTablesObservation struct {
}

type InputRecordTablesParameters struct {

	// +kubebuilder:validation:Optional
	CatalogID *string `json:"catalogId,omitempty" tf:"catalog_id,omitempty"`

	// +kubebuilder:validation:Optional
	ConnectionName *string `json:"connectionName,omitempty" tf:"connection_name,omitempty"`

	// +kubebuilder:validation:Required
	DatabaseName *string `json:"databaseName" tf:"database_name,omitempty"`

	// +kubebuilder:validation:Required
	TableName *string `json:"tableName" tf:"table_name,omitempty"`
}

type MlTransformObservation struct {
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	LabelCount *int64 `json:"labelCount,omitempty" tf:"label_count,omitempty"`

	Schema []SchemaObservation `json:"schema,omitempty" tf:"schema,omitempty"`

	TagsAll map[string]*string `json:"tagsAll,omitempty" tf:"tags_all,omitempty"`
}

type MlTransformParameters struct {

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	GlueVersion *string `json:"glueVersion,omitempty" tf:"glue_version,omitempty"`

	// +kubebuilder:validation:Required
	InputRecordTables []InputRecordTablesParameters `json:"inputRecordTables" tf:"input_record_tables,omitempty"`

	// +kubebuilder:validation:Optional
	MaxCapacity *float64 `json:"maxCapacity,omitempty" tf:"max_capacity,omitempty"`

	// +kubebuilder:validation:Optional
	MaxRetries *int64 `json:"maxRetries,omitempty" tf:"max_retries,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	NumberOfWorkers *int64 `json:"numberOfWorkers,omitempty" tf:"number_of_workers,omitempty"`

	// +kubebuilder:validation:Required
	Parameters []ParametersParameters `json:"parameters" tf:"parameters,omitempty"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"-"`

	// +kubebuilder:validation:Required
	RoleArn *string `json:"roleArn" tf:"role_arn,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Optional
	Timeout *int64 `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// +kubebuilder:validation:Optional
	WorkerType *string `json:"workerType,omitempty" tf:"worker_type,omitempty"`
}

type ParametersObservation struct {
}

type ParametersParameters struct {

	// +kubebuilder:validation:Required
	FindMatchesParameters []FindMatchesParametersParameters `json:"findMatchesParameters" tf:"find_matches_parameters,omitempty"`

	// +kubebuilder:validation:Required
	TransformType *string `json:"transformType" tf:"transform_type,omitempty"`
}

type SchemaObservation struct {
	DataType *string `json:"dataType,omitempty" tf:"data_type,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type SchemaParameters struct {
}

// MlTransformSpec defines the desired state of MlTransform
type MlTransformSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     MlTransformParameters `json:"forProvider"`
}

// MlTransformStatus defines the observed state of MlTransform.
type MlTransformStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        MlTransformObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// MlTransform is the Schema for the MlTransforms API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tfaws}
type MlTransform struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MlTransformSpec   `json:"spec"`
	Status            MlTransformStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MlTransformList contains a list of MlTransforms
type MlTransformList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []MlTransform `json:"items"`
}

// Repository type metadata.
var (
	MlTransformKind             = "MlTransform"
	MlTransformGroupKind        = schema.GroupKind{Group: Group, Kind: MlTransformKind}.String()
	MlTransformKindAPIVersion   = MlTransformKind + "." + GroupVersion.String()
	MlTransformGroupVersionKind = GroupVersion.WithKind(MlTransformKind)
)

func init() {
	SchemeBuilder.Register(&MlTransform{}, &MlTransformList{})
}
