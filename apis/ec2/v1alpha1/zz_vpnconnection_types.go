/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type RoutesObservation struct {
	DestinationCidrBlock *string `json:"destinationCidrBlock,omitempty" tf:"destination_cidr_block,omitempty"`

	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	State *string `json:"state,omitempty" tf:"state,omitempty"`
}

type RoutesParameters struct {
}

type VPNConnectionObservation struct {
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	CustomerGatewayConfiguration *string `json:"customerGatewayConfiguration,omitempty" tf:"customer_gateway_configuration,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Routes []RoutesObservation `json:"routes,omitempty" tf:"routes,omitempty"`

	TagsAll map[string]*string `json:"tagsAll,omitempty" tf:"tags_all,omitempty"`

	TransitGatewayAttachmentID *string `json:"transitGatewayAttachmentId,omitempty" tf:"transit_gateway_attachment_id,omitempty"`

	Tunnel1Address *string `json:"tunnel1Address,omitempty" tf:"tunnel1_address,omitempty"`

	Tunnel1BGPAsn *string `json:"tunnel1BgpAsn,omitempty" tf:"tunnel1_bgp_asn,omitempty"`

	Tunnel1BGPHoldtime *float64 `json:"tunnel1BgpHoldtime,omitempty" tf:"tunnel1_bgp_holdtime,omitempty"`

	Tunnel1CgwInsideAddress *string `json:"tunnel1CgwInsideAddress,omitempty" tf:"tunnel1_cgw_inside_address,omitempty"`

	Tunnel1VgwInsideAddress *string `json:"tunnel1VgwInsideAddress,omitempty" tf:"tunnel1_vgw_inside_address,omitempty"`

	Tunnel2Address *string `json:"tunnel2Address,omitempty" tf:"tunnel2_address,omitempty"`

	Tunnel2BGPAsn *string `json:"tunnel2BgpAsn,omitempty" tf:"tunnel2_bgp_asn,omitempty"`

	Tunnel2BGPHoldtime *float64 `json:"tunnel2BgpHoldtime,omitempty" tf:"tunnel2_bgp_holdtime,omitempty"`

	Tunnel2CgwInsideAddress *string `json:"tunnel2CgwInsideAddress,omitempty" tf:"tunnel2_cgw_inside_address,omitempty"`

	Tunnel2VgwInsideAddress *string `json:"tunnel2VgwInsideAddress,omitempty" tf:"tunnel2_vgw_inside_address,omitempty"`

	VgwTelemetry []VgwTelemetryObservation `json:"vgwTelemetry,omitempty" tf:"vgw_telemetry,omitempty"`
}

type VPNConnectionParameters struct {

	// +kubebuilder:validation:Required
	CustomerGatewayID *string `json:"customerGatewayId" tf:"customer_gateway_id,omitempty"`

	// +kubebuilder:validation:Optional
	EnableAcceleration *bool `json:"enableAcceleration,omitempty" tf:"enable_acceleration,omitempty"`

	// +kubebuilder:validation:Optional
	LocalIPv4NetworkCidr *string `json:"localIpv4NetworkCidr,omitempty" tf:"local_ipv4_network_cidr,omitempty"`

	// +kubebuilder:validation:Optional
	LocalIPv6NetworkCidr *string `json:"localIpv6NetworkCidr,omitempty" tf:"local_ipv6_network_cidr,omitempty"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"-"`

	// +kubebuilder:validation:Optional
	RemoteIPv4NetworkCidr *string `json:"remoteIpv4NetworkCidr,omitempty" tf:"remote_ipv4_network_cidr,omitempty"`

	// +kubebuilder:validation:Optional
	RemoteIPv6NetworkCidr *string `json:"remoteIpv6NetworkCidr,omitempty" tf:"remote_ipv6_network_cidr,omitempty"`

	// +kubebuilder:validation:Optional
	StaticRoutesOnly *bool `json:"staticRoutesOnly,omitempty" tf:"static_routes_only,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Optional
	TransitGatewayID *string `json:"transitGatewayId,omitempty" tf:"transit_gateway_id,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel1DpdTimeoutAction *string `json:"tunnel1DpdTimeoutAction,omitempty" tf:"tunnel1_dpd_timeout_action,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel1DpdTimeoutSeconds *float64 `json:"tunnel1DpdTimeoutSeconds,omitempty" tf:"tunnel1_dpd_timeout_seconds,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel1IkeVersions []*string `json:"tunnel1IkeVersions,omitempty" tf:"tunnel1_ike_versions,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel1InsideCidr *string `json:"tunnel1InsideCidr,omitempty" tf:"tunnel1_inside_cidr,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel1InsideIPv6Cidr *string `json:"tunnel1InsideIpv6Cidr,omitempty" tf:"tunnel1_inside_ipv6_cidr,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel1Phase1DhGroupNumbers []*float64 `json:"tunnel1Phase1DhGroupNumbers,omitempty" tf:"tunnel1_phase1_dh_group_numbers,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel1Phase1EncryptionAlgorithms []*string `json:"tunnel1Phase1EncryptionAlgorithms,omitempty" tf:"tunnel1_phase1_encryption_algorithms,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel1Phase1IntegrityAlgorithms []*string `json:"tunnel1Phase1IntegrityAlgorithms,omitempty" tf:"tunnel1_phase1_integrity_algorithms,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel1Phase1LifetimeSeconds *float64 `json:"tunnel1Phase1LifetimeSeconds,omitempty" tf:"tunnel1_phase1_lifetime_seconds,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel1Phase2DhGroupNumbers []*float64 `json:"tunnel1Phase2DhGroupNumbers,omitempty" tf:"tunnel1_phase2_dh_group_numbers,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel1Phase2EncryptionAlgorithms []*string `json:"tunnel1Phase2EncryptionAlgorithms,omitempty" tf:"tunnel1_phase2_encryption_algorithms,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel1Phase2IntegrityAlgorithms []*string `json:"tunnel1Phase2IntegrityAlgorithms,omitempty" tf:"tunnel1_phase2_integrity_algorithms,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel1Phase2LifetimeSeconds *float64 `json:"tunnel1Phase2LifetimeSeconds,omitempty" tf:"tunnel1_phase2_lifetime_seconds,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel1PresharedKeySecretRef *v1.SecretKeySelector `json:"tunnel1PresharedKeySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Tunnel1RekeyFuzzPercentage *float64 `json:"tunnel1RekeyFuzzPercentage,omitempty" tf:"tunnel1_rekey_fuzz_percentage,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel1RekeyMarginTimeSeconds *float64 `json:"tunnel1RekeyMarginTimeSeconds,omitempty" tf:"tunnel1_rekey_margin_time_seconds,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel1ReplayWindowSize *float64 `json:"tunnel1ReplayWindowSize,omitempty" tf:"tunnel1_replay_window_size,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel1StartupAction *string `json:"tunnel1StartupAction,omitempty" tf:"tunnel1_startup_action,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel2DpdTimeoutAction *string `json:"tunnel2DpdTimeoutAction,omitempty" tf:"tunnel2_dpd_timeout_action,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel2DpdTimeoutSeconds *float64 `json:"tunnel2DpdTimeoutSeconds,omitempty" tf:"tunnel2_dpd_timeout_seconds,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel2IkeVersions []*string `json:"tunnel2IkeVersions,omitempty" tf:"tunnel2_ike_versions,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel2InsideCidr *string `json:"tunnel2InsideCidr,omitempty" tf:"tunnel2_inside_cidr,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel2InsideIPv6Cidr *string `json:"tunnel2InsideIpv6Cidr,omitempty" tf:"tunnel2_inside_ipv6_cidr,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel2Phase1DhGroupNumbers []*float64 `json:"tunnel2Phase1DhGroupNumbers,omitempty" tf:"tunnel2_phase1_dh_group_numbers,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel2Phase1EncryptionAlgorithms []*string `json:"tunnel2Phase1EncryptionAlgorithms,omitempty" tf:"tunnel2_phase1_encryption_algorithms,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel2Phase1IntegrityAlgorithms []*string `json:"tunnel2Phase1IntegrityAlgorithms,omitempty" tf:"tunnel2_phase1_integrity_algorithms,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel2Phase1LifetimeSeconds *float64 `json:"tunnel2Phase1LifetimeSeconds,omitempty" tf:"tunnel2_phase1_lifetime_seconds,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel2Phase2DhGroupNumbers []*float64 `json:"tunnel2Phase2DhGroupNumbers,omitempty" tf:"tunnel2_phase2_dh_group_numbers,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel2Phase2EncryptionAlgorithms []*string `json:"tunnel2Phase2EncryptionAlgorithms,omitempty" tf:"tunnel2_phase2_encryption_algorithms,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel2Phase2IntegrityAlgorithms []*string `json:"tunnel2Phase2IntegrityAlgorithms,omitempty" tf:"tunnel2_phase2_integrity_algorithms,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel2Phase2LifetimeSeconds *float64 `json:"tunnel2Phase2LifetimeSeconds,omitempty" tf:"tunnel2_phase2_lifetime_seconds,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel2PresharedKeySecretRef *v1.SecretKeySelector `json:"tunnel2PresharedKeySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Tunnel2RekeyFuzzPercentage *float64 `json:"tunnel2RekeyFuzzPercentage,omitempty" tf:"tunnel2_rekey_fuzz_percentage,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel2RekeyMarginTimeSeconds *float64 `json:"tunnel2RekeyMarginTimeSeconds,omitempty" tf:"tunnel2_rekey_margin_time_seconds,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel2ReplayWindowSize *float64 `json:"tunnel2ReplayWindowSize,omitempty" tf:"tunnel2_replay_window_size,omitempty"`

	// +kubebuilder:validation:Optional
	Tunnel2StartupAction *string `json:"tunnel2StartupAction,omitempty" tf:"tunnel2_startup_action,omitempty"`

	// +kubebuilder:validation:Optional
	TunnelInsideIPVersion *string `json:"tunnelInsideIpVersion,omitempty" tf:"tunnel_inside_ip_version,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`

	// +kubebuilder:validation:Optional
	VPNGatewayID *string `json:"vpnGatewayId,omitempty" tf:"vpn_gateway_id,omitempty"`
}

type VgwTelemetryObservation struct {
	AcceptedRouteCount *float64 `json:"acceptedRouteCount,omitempty" tf:"accepted_route_count,omitempty"`

	LastStatusChange *string `json:"lastStatusChange,omitempty" tf:"last_status_change,omitempty"`

	OutsideIPAddress *string `json:"outsideIpAddress,omitempty" tf:"outside_ip_address,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	StatusMessage *string `json:"statusMessage,omitempty" tf:"status_message,omitempty"`
}

type VgwTelemetryParameters struct {
}

// VPNConnectionSpec defines the desired state of VPNConnection
type VPNConnectionSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     VPNConnectionParameters `json:"forProvider"`
}

// VPNConnectionStatus defines the observed state of VPNConnection.
type VPNConnectionStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        VPNConnectionObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// VPNConnection is the Schema for the VPNConnections API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,awsjet}
type VPNConnection struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              VPNConnectionSpec   `json:"spec"`
	Status            VPNConnectionStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// VPNConnectionList contains a list of VPNConnections
type VPNConnectionList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VPNConnection `json:"items"`
}

// Repository type metadata.
var (
	VPNConnection_Kind             = "VPNConnection"
	VPNConnection_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: VPNConnection_Kind}.String()
	VPNConnection_KindAPIVersion   = VPNConnection_Kind + "." + CRDGroupVersion.String()
	VPNConnection_GroupVersionKind = CRDGroupVersion.WithKind(VPNConnection_Kind)
)

func init() {
	SchemeBuilder.Register(&VPNConnection{}, &VPNConnectionList{})
}
