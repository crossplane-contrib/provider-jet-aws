/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type BlockDeviceMappingsObservation struct {
}

type BlockDeviceMappingsParameters struct {

	// +kubebuilder:validation:Optional
	DeviceName *string `json:"deviceName,omitempty" tf:"device_name,omitempty"`

	// +kubebuilder:validation:Optional
	Ebs []EbsParameters `json:"ebs,omitempty" tf:"ebs,omitempty"`

	// +kubebuilder:validation:Optional
	NoDevice *string `json:"noDevice,omitempty" tf:"no_device,omitempty"`

	// +kubebuilder:validation:Optional
	VirtualName *string `json:"virtualName,omitempty" tf:"virtual_name,omitempty"`
}

type CPUOptionsObservation struct {
}

type CPUOptionsParameters struct {

	// +kubebuilder:validation:Optional
	CoreCount *int64 `json:"coreCount,omitempty" tf:"core_count,omitempty"`

	// +kubebuilder:validation:Optional
	ThreadsPerCore *int64 `json:"threadsPerCore,omitempty" tf:"threads_per_core,omitempty"`
}

type CapacityReservationSpecificationCapacityReservationTargetObservation struct {
}

type CapacityReservationSpecificationCapacityReservationTargetParameters struct {

	// +kubebuilder:validation:Optional
	CapacityReservationID *string `json:"capacityReservationId,omitempty" tf:"capacity_reservation_id,omitempty"`
}

type EC2LaunchTemplateCapacityReservationSpecificationObservation struct {
}

type EC2LaunchTemplateCapacityReservationSpecificationParameters struct {

	// +kubebuilder:validation:Optional
	CapacityReservationPreference *string `json:"capacityReservationPreference,omitempty" tf:"capacity_reservation_preference,omitempty"`

	// +kubebuilder:validation:Optional
	CapacityReservationTarget []CapacityReservationSpecificationCapacityReservationTargetParameters `json:"capacityReservationTarget,omitempty" tf:"capacity_reservation_target,omitempty"`
}

type EC2LaunchTemplateCreditSpecificationObservation struct {
}

type EC2LaunchTemplateCreditSpecificationParameters struct {

	// +kubebuilder:validation:Optional
	CPUCredits *string `json:"cpuCredits,omitempty" tf:"cpu_credits,omitempty"`
}

type EC2LaunchTemplateEnclaveOptionsObservation struct {
}

type EC2LaunchTemplateEnclaveOptionsParameters struct {

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type EC2LaunchTemplateMetadataOptionsObservation struct {
}

type EC2LaunchTemplateMetadataOptionsParameters struct {

	// +kubebuilder:validation:Optional
	HTTPEndpoint *string `json:"httpEndpoint,omitempty" tf:"http_endpoint,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPPutResponseHopLimit *int64 `json:"httpPutResponseHopLimit,omitempty" tf:"http_put_response_hop_limit,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPTokens *string `json:"httpTokens,omitempty" tf:"http_tokens,omitempty"`
}

type EC2LaunchTemplateObservation struct {
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	LatestVersion *int64 `json:"latestVersion,omitempty" tf:"latest_version,omitempty"`

	TagsAll map[string]*string `json:"tagsAll,omitempty" tf:"tags_all,omitempty"`
}

type EC2LaunchTemplateParameters struct {

	// +kubebuilder:validation:Optional
	BlockDeviceMappings []BlockDeviceMappingsParameters `json:"blockDeviceMappings,omitempty" tf:"block_device_mappings,omitempty"`

	// +kubebuilder:validation:Optional
	CPUOptions []CPUOptionsParameters `json:"cpuOptions,omitempty" tf:"cpu_options,omitempty"`

	// +kubebuilder:validation:Optional
	CapacityReservationSpecification []EC2LaunchTemplateCapacityReservationSpecificationParameters `json:"capacityReservationSpecification,omitempty" tf:"capacity_reservation_specification,omitempty"`

	// +kubebuilder:validation:Optional
	CreditSpecification []EC2LaunchTemplateCreditSpecificationParameters `json:"creditSpecification,omitempty" tf:"credit_specification,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultVersion *int64 `json:"defaultVersion,omitempty" tf:"default_version,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	DisableAPITermination *bool `json:"disableApiTermination,omitempty" tf:"disable_api_termination,omitempty"`

	// +kubebuilder:validation:Optional
	EbsOptimized *string `json:"ebsOptimized,omitempty" tf:"ebs_optimized,omitempty"`

	// +kubebuilder:validation:Optional
	ElasticGpuSpecifications []ElasticGpuSpecificationsParameters `json:"elasticGpuSpecifications,omitempty" tf:"elastic_gpu_specifications,omitempty"`

	// +kubebuilder:validation:Optional
	ElasticInferenceAccelerator []ElasticInferenceAcceleratorParameters `json:"elasticInferenceAccelerator,omitempty" tf:"elastic_inference_accelerator,omitempty"`

	// +kubebuilder:validation:Optional
	EnclaveOptions []EC2LaunchTemplateEnclaveOptionsParameters `json:"enclaveOptions,omitempty" tf:"enclave_options,omitempty"`

	// +kubebuilder:validation:Optional
	HibernationOptions []HibernationOptionsParameters `json:"hibernationOptions,omitempty" tf:"hibernation_options,omitempty"`

	// +kubebuilder:validation:Optional
	IamInstanceProfile []IamInstanceProfileParameters `json:"iamInstanceProfile,omitempty" tf:"iam_instance_profile,omitempty"`

	// +kubebuilder:validation:Optional
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// +kubebuilder:validation:Optional
	InstanceInitiatedShutdownBehavior *string `json:"instanceInitiatedShutdownBehavior,omitempty" tf:"instance_initiated_shutdown_behavior,omitempty"`

	// +kubebuilder:validation:Optional
	InstanceMarketOptions []InstanceMarketOptionsParameters `json:"instanceMarketOptions,omitempty" tf:"instance_market_options,omitempty"`

	// +kubebuilder:validation:Optional
	InstanceType *string `json:"instanceType,omitempty" tf:"instance_type,omitempty"`

	// +kubebuilder:validation:Optional
	KernelID *string `json:"kernelId,omitempty" tf:"kernel_id,omitempty"`

	// +kubebuilder:validation:Optional
	KeyName *string `json:"keyName,omitempty" tf:"key_name,omitempty"`

	// +kubebuilder:validation:Optional
	LicenseSpecification []LicenseSpecificationParameters `json:"licenseSpecification,omitempty" tf:"license_specification,omitempty"`

	// +kubebuilder:validation:Optional
	MetadataOptions []EC2LaunchTemplateMetadataOptionsParameters `json:"metadataOptions,omitempty" tf:"metadata_options,omitempty"`

	// +kubebuilder:validation:Optional
	Monitoring []MonitoringParameters `json:"monitoring,omitempty" tf:"monitoring,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	NamePrefix *string `json:"namePrefix,omitempty" tf:"name_prefix,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkInterfaces []NetworkInterfacesParameters `json:"networkInterfaces,omitempty" tf:"network_interfaces,omitempty"`

	// +kubebuilder:validation:Optional
	Placement []PlacementParameters `json:"placement,omitempty" tf:"placement,omitempty"`

	// +kubebuilder:validation:Optional
	RAMDiskID *string `json:"ramDiskId,omitempty" tf:"ram_disk_id,omitempty"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"-"`

	// +crossplane:generate:reference:type=SecurityGroup
	// +kubebuilder:validation:Optional
	SecurityGroupNames []*string `json:"securityGroupNames,omitempty" tf:"security_group_names,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityGroupNamesRefs []v1.Reference `json:"securityGroupNamesRefs,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	SecurityGroupNamesSelector *v1.Selector `json:"securityGroupNamesSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	TagSpecifications []TagSpecificationsParameters `json:"tagSpecifications,omitempty" tf:"tag_specifications,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Optional
	UpdateDefaultVersion *bool `json:"updateDefaultVersion,omitempty" tf:"update_default_version,omitempty"`

	// +kubebuilder:validation:Optional
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`

	// +crossplane:generate:reference:type=SecurityGroup
	// +kubebuilder:validation:Optional
	VpcSecurityGroupIds []*string `json:"vpcSecurityGroupIds,omitempty" tf:"vpc_security_group_ids,omitempty"`

	// +kubebuilder:validation:Optional
	VpcSecurityGroupIdsRefs []v1.Reference `json:"vpcSecurityGroupIdsRefs,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	VpcSecurityGroupIdsSelector *v1.Selector `json:"vpcSecurityGroupIdsSelector,omitempty" tf:"-"`
}

type EbsObservation struct {
}

type EbsParameters struct {

	// +kubebuilder:validation:Optional
	DeleteOnTermination *string `json:"deleteOnTermination,omitempty" tf:"delete_on_termination,omitempty"`

	// +kubebuilder:validation:Optional
	Encrypted *string `json:"encrypted,omitempty" tf:"encrypted,omitempty"`

	// +kubebuilder:validation:Optional
	Iops *int64 `json:"iops,omitempty" tf:"iops,omitempty"`

	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-tf-aws/apis/kms/v1alpha1.Key
	// +kubebuilder:validation:Optional
	KmsKeyID *string `json:"kmsKeyId,omitempty" tf:"kms_key_id,omitempty"`

	// +kubebuilder:validation:Optional
	KmsKeyIDRef *v1.Reference `json:"kmsKeyIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	KmsKeyIDSelector *v1.Selector `json:"kmsKeyIdSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	SnapshotID *string `json:"snapshotId,omitempty" tf:"snapshot_id,omitempty"`

	// +kubebuilder:validation:Optional
	Throughput *int64 `json:"throughput,omitempty" tf:"throughput,omitempty"`

	// +kubebuilder:validation:Optional
	VolumeSize *int64 `json:"volumeSize,omitempty" tf:"volume_size,omitempty"`

	// +kubebuilder:validation:Optional
	VolumeType *string `json:"volumeType,omitempty" tf:"volume_type,omitempty"`
}

type ElasticGpuSpecificationsObservation struct {
}

type ElasticGpuSpecificationsParameters struct {

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type ElasticInferenceAcceleratorObservation struct {
}

type ElasticInferenceAcceleratorParameters struct {

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type HibernationOptionsObservation struct {
}

type HibernationOptionsParameters struct {

	// +kubebuilder:validation:Required
	Configured *bool `json:"configured" tf:"configured,omitempty"`
}

type IamInstanceProfileObservation struct {
}

type IamInstanceProfileParameters struct {

	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-tf-aws/apis/iam/v1alpha1.InstanceProfile
	// +crossplane:generate:reference:extractor=github.com/crossplane-contrib/provider-tf-aws/config/common.ARNExtractor()
	// +kubebuilder:validation:Optional
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	// +kubebuilder:validation:Optional
	ArnRef *v1.Reference `json:"arnRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ArnSelector *v1.Selector `json:"arnSelector,omitempty" tf:"-"`

	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-tf-aws/apis/iam/v1alpha1.InstanceProfile
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	NameRef *v1.Reference `json:"nameRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	NameSelector *v1.Selector `json:"nameSelector,omitempty" tf:"-"`
}

type InstanceMarketOptionsObservation struct {
}

type InstanceMarketOptionsParameters struct {

	// +kubebuilder:validation:Optional
	MarketType *string `json:"marketType,omitempty" tf:"market_type,omitempty"`

	// +kubebuilder:validation:Optional
	SpotOptions []InstanceMarketOptionsSpotOptionsParameters `json:"spotOptions,omitempty" tf:"spot_options,omitempty"`
}

type InstanceMarketOptionsSpotOptionsObservation struct {
}

type InstanceMarketOptionsSpotOptionsParameters struct {

	// +kubebuilder:validation:Optional
	BlockDurationMinutes *int64 `json:"blockDurationMinutes,omitempty" tf:"block_duration_minutes,omitempty"`

	// +kubebuilder:validation:Optional
	InstanceInterruptionBehavior *string `json:"instanceInterruptionBehavior,omitempty" tf:"instance_interruption_behavior,omitempty"`

	// +kubebuilder:validation:Optional
	MaxPrice *string `json:"maxPrice,omitempty" tf:"max_price,omitempty"`

	// +kubebuilder:validation:Optional
	SpotInstanceType *string `json:"spotInstanceType,omitempty" tf:"spot_instance_type,omitempty"`

	// +kubebuilder:validation:Optional
	ValidUntil *string `json:"validUntil,omitempty" tf:"valid_until,omitempty"`
}

type LicenseSpecificationObservation struct {
}

type LicenseSpecificationParameters struct {

	// +kubebuilder:validation:Required
	LicenseConfigurationArn *string `json:"licenseConfigurationArn" tf:"license_configuration_arn,omitempty"`
}

type MonitoringObservation struct {
}

type MonitoringParameters struct {

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type NetworkInterfacesObservation struct {
}

type NetworkInterfacesParameters struct {

	// +kubebuilder:validation:Optional
	AssociateCarrierIPAddress *string `json:"associateCarrierIpAddress,omitempty" tf:"associate_carrier_ip_address,omitempty"`

	// +kubebuilder:validation:Optional
	AssociatePublicIPAddress *string `json:"associatePublicIpAddress,omitempty" tf:"associate_public_ip_address,omitempty"`

	// +kubebuilder:validation:Optional
	DeleteOnTermination *string `json:"deleteOnTermination,omitempty" tf:"delete_on_termination,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	DeviceIndex *int64 `json:"deviceIndex,omitempty" tf:"device_index,omitempty"`

	// +kubebuilder:validation:Optional
	IPv4AddressCount *int64 `json:"ipv4AddressCount,omitempty" tf:"ipv4_address_count,omitempty"`

	// +kubebuilder:validation:Optional
	IPv4Addresses []*string `json:"ipv4Addresses,omitempty" tf:"ipv4_addresses,omitempty"`

	// +kubebuilder:validation:Optional
	IPv6AddressCount *int64 `json:"ipv6AddressCount,omitempty" tf:"ipv6_address_count,omitempty"`

	// +kubebuilder:validation:Optional
	IPv6Addresses []*string `json:"ipv6Addresses,omitempty" tf:"ipv6_addresses,omitempty"`

	// +kubebuilder:validation:Optional
	InterfaceType *string `json:"interfaceType,omitempty" tf:"interface_type,omitempty"`

	// +crossplane:generate:reference:type=EC2NetworkInterface
	// +kubebuilder:validation:Optional
	NetworkInterfaceID *string `json:"networkInterfaceId,omitempty" tf:"network_interface_id,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkInterfaceIDRef *v1.Reference `json:"networkInterfaceIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	NetworkInterfaceIDSelector *v1.Selector `json:"networkInterfaceIdSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	PrivateIPAddress *string `json:"privateIpAddress,omitempty" tf:"private_ip_address,omitempty"`

	// +crossplane:generate:reference:type=SecurityGroup
	// +kubebuilder:validation:Optional
	SecurityGroups []*string `json:"securityGroups,omitempty" tf:"security_groups,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityGroupsRefs []v1.Reference `json:"securityGroupsRefs,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	SecurityGroupsSelector *v1.Selector `json:"securityGroupsSelector,omitempty" tf:"-"`

	// +crossplane:generate:reference:type=Subnet
	// +kubebuilder:validation:Optional
	SubnetID *string `json:"subnetId,omitempty" tf:"subnet_id,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetIDRef *v1.Reference `json:"subnetIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	SubnetIDSelector *v1.Selector `json:"subnetIdSelector,omitempty" tf:"-"`
}

type PlacementObservation struct {
}

type PlacementParameters struct {

	// +kubebuilder:validation:Optional
	Affinity *string `json:"affinity,omitempty" tf:"affinity,omitempty"`

	// +kubebuilder:validation:Optional
	AvailabilityZone *string `json:"availabilityZone,omitempty" tf:"availability_zone,omitempty"`

	// +kubebuilder:validation:Optional
	GroupName *string `json:"groupName,omitempty" tf:"group_name,omitempty"`

	// +kubebuilder:validation:Optional
	HostID *string `json:"hostId,omitempty" tf:"host_id,omitempty"`

	// +kubebuilder:validation:Optional
	HostResourceGroupArn *string `json:"hostResourceGroupArn,omitempty" tf:"host_resource_group_arn,omitempty"`

	// +kubebuilder:validation:Optional
	PartitionNumber *int64 `json:"partitionNumber,omitempty" tf:"partition_number,omitempty"`

	// +kubebuilder:validation:Optional
	SpreadDomain *string `json:"spreadDomain,omitempty" tf:"spread_domain,omitempty"`

	// +kubebuilder:validation:Optional
	Tenancy *string `json:"tenancy,omitempty" tf:"tenancy,omitempty"`
}

type TagSpecificationsObservation struct {
}

type TagSpecificationsParameters struct {

	// +kubebuilder:validation:Optional
	ResourceType *string `json:"resourceType,omitempty" tf:"resource_type,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`
}

// EC2LaunchTemplateSpec defines the desired state of EC2LaunchTemplate
type EC2LaunchTemplateSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     EC2LaunchTemplateParameters `json:"forProvider"`
}

// EC2LaunchTemplateStatus defines the observed state of EC2LaunchTemplate.
type EC2LaunchTemplateStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        EC2LaunchTemplateObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// EC2LaunchTemplate is the Schema for the EC2LaunchTemplates API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tfaws}
type EC2LaunchTemplate struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              EC2LaunchTemplateSpec   `json:"spec"`
	Status            EC2LaunchTemplateStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// EC2LaunchTemplateList contains a list of EC2LaunchTemplates
type EC2LaunchTemplateList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []EC2LaunchTemplate `json:"items"`
}

// Repository type metadata.
var (
	EC2LaunchTemplateKind             = "EC2LaunchTemplate"
	EC2LaunchTemplateGroupKind        = schema.GroupKind{Group: Group, Kind: EC2LaunchTemplateKind}.String()
	EC2LaunchTemplateKindAPIVersion   = EC2LaunchTemplateKind + "." + GroupVersion.String()
	EC2LaunchTemplateGroupVersionKind = GroupVersion.WithKind(EC2LaunchTemplateKind)
)

func init() {
	SchemeBuilder.Register(&EC2LaunchTemplate{}, &EC2LaunchTemplateList{})
}
