/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type AccessLogsObservation struct {
}

type AccessLogsParameters struct {

	// +kubebuilder:validation:Required
	Bucket string `json:"bucket" tf:"bucket"`

	// +kubebuilder:validation:Optional
	BucketPrefix *string `json:"bucketPrefix,omitempty" tf:"bucket_prefix"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`

	// +kubebuilder:validation:Optional
	Interval *int64 `json:"interval,omitempty" tf:"interval"`
}

type ElbObservation struct {
	Arn string `json:"arn,omitempty" tf:"arn"`

	DNSName string `json:"dnsName,omitempty" tf:"dns_name"`

	SourceSecurityGroupID string `json:"sourceSecurityGroupId,omitempty" tf:"source_security_group_id"`

	ZoneID string `json:"zoneId,omitempty" tf:"zone_id"`
}

type ElbParameters struct {

	// +kubebuilder:validation:Optional
	AccessLogs []AccessLogsParameters `json:"accessLogs,omitempty" tf:"access_logs"`

	// +kubebuilder:validation:Optional
	AvailabilityZones []string `json:"availabilityZones,omitempty" tf:"availability_zones"`

	// +kubebuilder:validation:Optional
	ConnectionDraining *bool `json:"connectionDraining,omitempty" tf:"connection_draining"`

	// +kubebuilder:validation:Optional
	ConnectionDrainingTimeout *int64 `json:"connectionDrainingTimeout,omitempty" tf:"connection_draining_timeout"`

	// +kubebuilder:validation:Optional
	CrossZoneLoadBalancing *bool `json:"crossZoneLoadBalancing,omitempty" tf:"cross_zone_load_balancing"`

	// +kubebuilder:validation:Optional
	HealthCheck []HealthCheckParameters `json:"healthCheck,omitempty" tf:"health_check"`

	// +kubebuilder:validation:Optional
	IdleTimeout *int64 `json:"idleTimeout,omitempty" tf:"idle_timeout"`

	// +kubebuilder:validation:Optional
	Instances []string `json:"instances,omitempty" tf:"instances"`

	// +kubebuilder:validation:Optional
	Internal *bool `json:"internal,omitempty" tf:"internal"`

	// +kubebuilder:validation:Required
	Listener []ListenerParameters `json:"listener" tf:"listener"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name"`

	// +kubebuilder:validation:Optional
	NamePrefix *string `json:"namePrefix,omitempty" tf:"name_prefix"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region string `json:"region" tf:"-"`

	// +kubebuilder:validation:Optional
	SecurityGroups []string `json:"securityGroups,omitempty" tf:"security_groups"`

	// +kubebuilder:validation:Optional
	SourceSecurityGroup *string `json:"sourceSecurityGroup,omitempty" tf:"source_security_group"`

	// +kubebuilder:validation:Optional
	Subnets []string `json:"subnets,omitempty" tf:"subnets"`

	// +kubebuilder:validation:Optional
	Tags map[string]string `json:"tags,omitempty" tf:"tags"`

	// +kubebuilder:validation:Optional
	TagsAll map[string]string `json:"tagsAll,omitempty" tf:"tags_all"`
}

type HealthCheckObservation struct {
}

type HealthCheckParameters struct {

	// +kubebuilder:validation:Required
	HealthyThreshold int64 `json:"healthyThreshold" tf:"healthy_threshold"`

	// +kubebuilder:validation:Required
	Interval int64 `json:"interval" tf:"interval"`

	// +kubebuilder:validation:Required
	Target string `json:"target" tf:"target"`

	// +kubebuilder:validation:Required
	Timeout int64 `json:"timeout" tf:"timeout"`

	// +kubebuilder:validation:Required
	UnhealthyThreshold int64 `json:"unhealthyThreshold" tf:"unhealthy_threshold"`
}

type ListenerObservation struct {
}

type ListenerParameters struct {

	// +kubebuilder:validation:Required
	InstancePort int64 `json:"instancePort" tf:"instance_port"`

	// +kubebuilder:validation:Required
	InstanceProtocol string `json:"instanceProtocol" tf:"instance_protocol"`

	// +kubebuilder:validation:Required
	LbPort int64 `json:"lbPort" tf:"lb_port"`

	// +kubebuilder:validation:Required
	LbProtocol string `json:"lbProtocol" tf:"lb_protocol"`

	// +kubebuilder:validation:Optional
	SslCertificateID *string `json:"sslCertificateId,omitempty" tf:"ssl_certificate_id"`
}

// ElbSpec defines the desired state of Elb
type ElbSpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       ElbParameters `json:"forProvider"`
}

// ElbStatus defines the observed state of Elb.
type ElbStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          ElbObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Elb is the Schema for the Elbs API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tfaws}
type Elb struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ElbSpec   `json:"spec"`
	Status            ElbStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ElbList contains a list of Elbs
type ElbList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Elb `json:"items"`
}

// Repository type metadata.
var (
	ElbKind             = "Elb"
	ElbGroupKind        = schema.GroupKind{Group: Group, Kind: ElbKind}.String()
	ElbKindAPIVersion   = ElbKind + "." + GroupVersion.String()
	ElbGroupVersionKind = GroupVersion.WithKind(ElbKind)
)

func init() {
	SchemeBuilder.Register(&Elb{}, &ElbList{})
}
