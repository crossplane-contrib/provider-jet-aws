/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AccessLogsObservation struct {
}

type AccessLogsParameters struct {

	// +kubebuilder:validation:Required
	Bucket *string `json:"bucket" tf:"bucket,omitempty"`

	// +kubebuilder:validation:Optional
	BucketPrefix *string `json:"bucketPrefix,omitempty" tf:"bucket_prefix,omitempty"`

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Optional
	Interval *int64 `json:"interval,omitempty" tf:"interval,omitempty"`
}

type ElbObservation struct {
	Arn *string `json:"arn,omitempty" tf:"arn,omitempty"`

	DNSName *string `json:"dnsName,omitempty" tf:"dns_name,omitempty"`

	SourceSecurityGroupID *string `json:"sourceSecurityGroupId,omitempty" tf:"source_security_group_id,omitempty"`

	TagsAll map[string]*string `json:"tagsAll,omitempty" tf:"tags_all,omitempty"`

	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type ElbParameters struct {

	// +kubebuilder:validation:Optional
	AccessLogs []AccessLogsParameters `json:"accessLogs,omitempty" tf:"access_logs,omitempty"`

	// +kubebuilder:validation:Optional
	AvailabilityZones []*string `json:"availabilityZones,omitempty" tf:"availability_zones,omitempty"`

	// +kubebuilder:validation:Optional
	ConnectionDraining *bool `json:"connectionDraining,omitempty" tf:"connection_draining,omitempty"`

	// +kubebuilder:validation:Optional
	ConnectionDrainingTimeout *int64 `json:"connectionDrainingTimeout,omitempty" tf:"connection_draining_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	CrossZoneLoadBalancing *bool `json:"crossZoneLoadBalancing,omitempty" tf:"cross_zone_load_balancing,omitempty"`

	// +kubebuilder:validation:Optional
	HealthCheck []HealthCheckParameters `json:"healthCheck,omitempty" tf:"health_check,omitempty"`

	// +kubebuilder:validation:Optional
	IdleTimeout *int64 `json:"idleTimeout,omitempty" tf:"idle_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	Instances []*string `json:"instances,omitempty" tf:"instances,omitempty"`

	// +kubebuilder:validation:Optional
	Internal *bool `json:"internal,omitempty" tf:"internal,omitempty"`

	// +kubebuilder:validation:Required
	Listener []ListenerParameters `json:"listener" tf:"listener,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	NamePrefix *string `json:"namePrefix,omitempty" tf:"name_prefix,omitempty"`

	// Region is the region you'd like your resource to be created in.
	// +terrajet:crd:field:TFTag=-
	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"-"`

	// +kubebuilder:validation:Optional
	SecurityGroups []*string `json:"securityGroups,omitempty" tf:"security_groups,omitempty"`

	// +kubebuilder:validation:Optional
	SourceSecurityGroup *string `json:"sourceSecurityGroup,omitempty" tf:"source_security_group,omitempty"`

	// +kubebuilder:validation:Optional
	Subnets []*string `json:"subnets,omitempty" tf:"subnets,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`
}

type HealthCheckObservation struct {
}

type HealthCheckParameters struct {

	// +kubebuilder:validation:Required
	HealthyThreshold *int64 `json:"healthyThreshold" tf:"healthy_threshold,omitempty"`

	// +kubebuilder:validation:Required
	Interval *int64 `json:"interval" tf:"interval,omitempty"`

	// +kubebuilder:validation:Required
	Target *string `json:"target" tf:"target,omitempty"`

	// +kubebuilder:validation:Required
	Timeout *int64 `json:"timeout" tf:"timeout,omitempty"`

	// +kubebuilder:validation:Required
	UnhealthyThreshold *int64 `json:"unhealthyThreshold" tf:"unhealthy_threshold,omitempty"`
}

type ListenerObservation struct {
}

type ListenerParameters struct {

	// +kubebuilder:validation:Required
	InstancePort *int64 `json:"instancePort" tf:"instance_port,omitempty"`

	// +kubebuilder:validation:Required
	InstanceProtocol *string `json:"instanceProtocol" tf:"instance_protocol,omitempty"`

	// +kubebuilder:validation:Required
	LbPort *int64 `json:"lbPort" tf:"lb_port,omitempty"`

	// +kubebuilder:validation:Required
	LbProtocol *string `json:"lbProtocol" tf:"lb_protocol,omitempty"`

	// +kubebuilder:validation:Optional
	SslCertificateID *string `json:"sslCertificateId,omitempty" tf:"ssl_certificate_id,omitempty"`
}

// ElbSpec defines the desired state of Elb
type ElbSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ElbParameters `json:"forProvider"`
}

// ElbStatus defines the observed state of Elb.
type ElbStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ElbObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Elb is the Schema for the Elbs API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tfaws}
type Elb struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ElbSpec   `json:"spec"`
	Status            ElbStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ElbList contains a list of Elbs
type ElbList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Elb `json:"items"`
}

// Repository type metadata.
var (
	ElbKind             = "Elb"
	ElbGroupKind        = schema.GroupKind{Group: Group, Kind: ElbKind}.String()
	ElbKindAPIVersion   = ElbKind + "." + GroupVersion.String()
	ElbGroupVersionKind = GroupVersion.WithKind(ElbKind)
)

func init() {
	SchemeBuilder.Register(&Elb{}, &ElbList{})
}
